<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>luoqian</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="luoqian">
<meta property="og:url" content="https://vampireqian.github.io/page/2/index.html">
<meta property="og:site_name" content="luoqian">
<meta property="og:locale">
<meta property="article:author" content="luoqian">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="luoqian" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">luoqian</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://vampireqian.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-16网络编程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2017/11/01/16%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2017-10-31T16:00:00.000Z" itemprop="datePublished">2017-11-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/python/">python</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2017/11/01/16%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">网络编程</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Socket介绍</p>
<p>Socket套接字<br>Python中提供socket.py标准库，非常底层的接口库。<br>Socket是一种通用的网络编程接口，和网络层次没有一一对应的关系。</p>
<p>协议族<br>AF表示Address Family，用于socket()第一个参数</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>AF_INET</td>
<td>IPV4</td>
</tr>
<tr>
<td>AF_INET6</td>
<td>IPv6</td>
</tr>
<tr>
<td>AF_UNIX</td>
<td>Unix Domain Socket，windows没有</td>
</tr>
</tbody></table>
<p>socket类型<br>| 名称     | 含义                            |<br>| ——– | ——————————- |<br>| SOCK_STREAM| 面向连接的流套接字。默认值，TCP协议|<br>|SOCK_DGRAM |无连接的数据报文套接字。UDP协议      |</p>
<h2 id="TCP编程"><a href="#TCP编程" class="headerlink" title="TCP编程"></a>TCP编程</h2><p>Socket编程，需要两端，一般来说需要一个服务端、一个客户端，服务端称为Server，客户端称为Client</p>
<h3 id="TCP服务端编程"><a href="#TCP服务端编程" class="headerlink" title="TCP服务端编程"></a>TCP服务端编程</h3><hr>
<p>服务器端编程步骤</p>
<ul>
<li><p>创建Socket对象</p>
</li>
<li><p>绑定IP地址Address和端口Port。bind()方法</p>
<p>IPv4地址为一个二元组(‘IP地址字符串’, Port)</p>
</li>
<li><p>开始监听，将在指定的IP的端口上监听。listen()方法</p>
</li>
<li><p>获取用于传送数据的Socket对象  socket.accept() -&gt; (socket object, address info)<br>accept方法阻塞等待客户端建立连接，返回一个新的Socket对象和客户端地址的二元组<br>地址是远程客户端的地址，IPv4中它是一个二元组(clientaddr, port)</p>
<ul>
<li><p>接收数据<br>recv(bufsize[, flags]) 使用缓冲区接收数据</p>
</li>
<li><p>发送数据<br>send(bytes)发送数据</p>
</li>
</ul>
</li>
</ul>
<p>  查看监听端口</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">windows 命令</span><br><span class="line"><span class="meta">#</span><span class="bash"> netstat -anp tcp | findstr 9999</span></span><br><span class="line"></span><br><span class="line">linux命令</span><br><span class="line"><span class="meta">#</span><span class="bash"> netstat -tanl | grep 9999</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ss -tanl | grep 9999</span></span><br></pre></td></tr></table></figure>

<h3 id="练习——写一个一对多通信"><a href="#练习——写一个一对多通信" class="headerlink" title="练习——写一个一对多通信"></a>练习——写一个一对多通信</h3><p>  <strong>需求分析</strong></p>
<p>  聊天工具是CS程序，C是每一个客户端，S是服务器端。</p>
<p>  服务器应该具有的功能：<br>  启动服务，包括绑定地址和端口，并监听<br>  建立连接，能和多个客户端建立连接<br>  接收不同用户的信息<br>  分发，将接收的某个用户的信息转发到已连接的所有客户端<br>  停止服务<br>  记录连接的客户端</p>
<p>  <strong>代码实现</strong></p>
<p>  服务端应该对应一个类</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">logging.basicConfig(level=logging.INFO, <span class="built_in">format</span>=<span class="string">&quot;%(asctime)s %(thread)d %(message)s&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChatServer</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, ip=<span class="string">&#x27;127.0.0.1&#x27;</span>, port=<span class="number">9999</span></span>):</span> <span class="comment"># 启动服务</span></span><br><span class="line">        self.sock = socket.socket()</span><br><span class="line">        self.addr = (ip, port)</span><br><span class="line">        self.clients = &#123;&#125; <span class="comment"># 客户端</span></span><br><span class="line">        self.event = threading.Event()</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start</span>(<span class="params">self</span>):</span> <span class="comment"># 启动监听</span></span><br><span class="line">        self.sock.bind(self.addr) <span class="comment"># 绑定</span></span><br><span class="line">        self.sock.listen() <span class="comment"># 监听</span></span><br><span class="line">    	<span class="comment">#accept会阻塞主线程，所以开一个新线程</span></span><br><span class="line"> 	    threading.Thread(target=self.accept).start()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">accept</span>(<span class="params">self</span>):</span> <span class="comment"># 多人连接</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> self.event.is_set():</span><br><span class="line">            sock, client = self.sock.accept() <span class="comment"># 阻塞</span></span><br><span class="line">            self.clients[client] = sock <span class="comment"># 添加到客户端字典</span></span><br><span class="line">            <span class="comment">#准备接收数据，recv是阻塞的，开启新的线程</span></span><br><span class="line">            threading.Thread(target=self.recv, args=(sock, client)).start()</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">recv</span>(<span class="params">self, sock:socket.socket, client</span>):</span> <span class="comment"># 接收客户端数据</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> self.event.is_set():</span><br><span class="line">            data = sock.recv(<span class="number">1024</span>) <span class="comment"># 阻塞到数据到来</span></span><br><span class="line">            msg = data.decode().strip()</span><br><span class="line">            <span class="comment"># 客户端退出命令</span></span><br><span class="line">            <span class="keyword">if</span> msg == <span class="string">&#x27;quit&#x27;</span> <span class="keyword">or</span> msg == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">                self.clients.pop(client)</span><br><span class="line">                sock.close()</span><br><span class="line">                logging.info(<span class="string">&#x27;&#123;&#125; quits&#x27;</span>.<span class="built_in">format</span>(client))</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">            msg = <span class="string">&quot;&#123;:%Y/%m/%d %H:%M:%S&#125; &#123;&#125;:&#123;&#125;\n&#123;&#125;\n&quot;</span>.<span class="built_in">format</span>(datetime.datetime.now(), *client,data.decode())</span><br><span class="line">            logging.info(msg)</span><br><span class="line">            msg = msg.encode()</span><br><span class="line">            <span class="keyword">for</span> s <span class="keyword">in</span> self.clients.values():</span><br><span class="line">                s.send(msg)</span><br><span class="line">   </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">stop</span>(<span class="params">self</span>):</span> <span class="comment"># 停止服务</span></span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> self.clients.values():</span><br><span class="line">        	s.close()</span><br><span class="line">        self.sock.close()</span><br><span class="line">		self.event.<span class="built_in">set</span>()</span><br><span class="line">        </span><br><span class="line">cs = ChatServer()</span><br><span class="line">cs.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    cmd = <span class="built_in">input</span>(<span class="string">&#x27;&gt;&gt;&#x27;</span>).strip()</span><br><span class="line">    <span class="keyword">if</span> cmd == <span class="string">&#x27;quit&#x27;</span>:</span><br><span class="line">        cs.stop()</span><br><span class="line">        threading.Event().wait(<span class="number">3</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    logging.info(threading.<span class="built_in">enumerate</span>()) <span class="comment"># 用来观察断开后线程的变化</span></span><br></pre></td></tr></table></figure>

<h3 id="socket常用的方法"><a href="#socket常用的方法" class="headerlink" title="socket常用的方法"></a>socket常用的方法</h3><hr>
<table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>socket.recv(bufsize[, flags])</td>
<td>获取数据。默认是阻塞的方式</td>
</tr>
<tr>
<td>socket.recvfrom(bufsize[, flags])</td>
<td>获取数据，返回一个二元组(bytes, address)</td>
</tr>
<tr>
<td>socket.recv_into(buffer[, nbytes[,flags]])</td>
<td>获取到nbytes的数据后，存储到buffer中。如果nbytes没有指定或0，将buffer大小的数据存入buffer中。返回接收的字节数。</td>
</tr>
<tr>
<td>socket.recvfrom_into(buffer[,nbytes[, flags]])</td>
<td>获取数据，返回一个二元组(bytes, address)到buffer中</td>
</tr>
<tr>
<td>socket.send(bytes[, flags])</td>
<td>TCP发送数据</td>
</tr>
<tr>
<td>socket.sendall(bytes[, flags])</td>
<td>TCP发送全部数据，成功返回None</td>
</tr>
<tr>
<td>socket.sendto(string[,flag],address)</td>
<td>UDP发送数据</td>
</tr>
<tr>
<td>socket.sendfile(file, offset=0,count=None)</td>
<td>发送一个文件直到EOF，使用高性能的os.sendfile机制，返回发送的字节数。如果win下不支持sendfile，或者不是普通文件，使用send()发送文件。offset告诉起始位置。3.5版本开始</td>
</tr>
<tr>
<td>socket.getpeername()</td>
<td>返回连接套接字的远程地址。返回值通常是元组(ipaddr,port)</td>
</tr>
<tr>
<td>socket.getsockname()</td>
<td>返回套接字自己的地址。通常是一个元组(ipaddr,port)</td>
</tr>
<tr>
<td>socket.setblocking(flag)</td>
<td>如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常</td>
</tr>
<tr>
<td>socket.settimeout(value)</td>
<td>设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect())</td>
</tr>
<tr>
<td>socket.setsockopt(level,optname,value)</td>
<td>设置套接字选项的值。比如缓冲区大小。太多了，去看文档。不同系统，不同版本都不尽相同</td>
</tr>
</tbody></table>
<h3 id="MakeFile"><a href="#MakeFile" class="headerlink" title="MakeFile"></a>MakeFile</h3><hr>
<p><code>socket.makefile(mode=&#39;r&#39;, buffering=None, *, encoding=None, errors=None, newline=None)</code><br>创建一个与该套接字相关连的文件对象，将recv方法看做读方法，将send方法看做写方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用makefile简单例子</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">sockserver = socket.socket()</span><br><span class="line">ip = <span class="string">&#x27;127.0.0.1&#x27;</span></span><br><span class="line">port = <span class="number">9999</span></span><br><span class="line">addr = (ip, port)</span><br><span class="line">sockserver.bind(addr)</span><br><span class="line">sockserver.listen()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span><span class="number">30</span>)</span><br><span class="line">s, _ = sockserver.accept()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span><span class="number">30</span>)</span><br><span class="line">f = s.makefile(mode=<span class="string">&#x27;rw&#x27;</span>)</span><br><span class="line"></span><br><span class="line">line = f.read(<span class="number">10</span>) <span class="comment"># 阻塞等</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span><span class="number">30</span>)</span><br><span class="line"><span class="built_in">print</span>(line)</span><br><span class="line">f.write(<span class="string">&#x27;Return your msg: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(line))</span><br><span class="line">f.flush()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 改写成循环接收消息</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sockserver = socket.socket()</span><br><span class="line">ip = <span class="string">&#x27;127.0.0.1&#x27;</span></span><br><span class="line">port = <span class="number">9999</span></span><br><span class="line">addr = (ip, port)</span><br><span class="line">sockserver.bind(addr)</span><br><span class="line">sockserver.listen()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span><span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">event = threading.Event()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">accept</span>(<span class="params">sock:socket.socket, e:threading.Event</span>):</span></span><br><span class="line">    s, _ = sock.accept()</span><br><span class="line">    f = s.makefile(mode=<span class="string">&#x27;rw&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        line = f.readline()</span><br><span class="line">        <span class="built_in">print</span>(line)</span><br><span class="line">        <span class="keyword">if</span> line.strip() == <span class="string">&quot;quit&quot;</span>: <span class="comment"># 注意要发quit\n</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        f.write(<span class="string">&#x27;Return your msg: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(line))</span><br><span class="line">        f.flush()</span><br><span class="line">     f.close()</span><br><span class="line">     sock.close()</span><br><span class="line">     e.wait(<span class="number">3</span>)</span><br><span class="line">    </span><br><span class="line">t = threading.Thread(target=accept, args=(sockserver, event))</span><br><span class="line">t.start()</span><br><span class="line">t.join()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sockserver)</span><br></pre></td></tr></table></figure>

<h3 id="makefile练习"><a href="#makefile练习" class="headerlink" title="makefile练习"></a>makefile练习</h3><hr>
<p>使用makefile改写一对多通信</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">logging.basicConfig(level=logging.INFO, <span class="built_in">format</span>=<span class="string">&quot;%(asctime)s %(thread)d %(message)s&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChatServer</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init</span>(<span class="params">self, ip=<span class="string">&#x27;127.0.0.1&#x27;</span>, port=<span class="number">9999</span></span>):</span> <span class="comment"># 启动服务</span></span><br><span class="line">        self.sock = socket.socket()</span><br><span class="line">        self.addr = (ip, port)</span><br><span class="line">        self.clients = &#123;&#125; <span class="comment"># 客户端</span></span><br><span class="line">        self.event = threading.Event()</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start</span>(<span class="params">self</span>):</span> <span class="comment"># 启动监听</span></span><br><span class="line">        self.sock.bind(self.addr) <span class="comment"># 绑定</span></span><br><span class="line">        self.sock.listen() <span class="comment"># 监听</span></span><br><span class="line">        <span class="comment">#accept会阻塞主线程，所以开一个新线程</span></span><br><span class="line">        threading.Thread(target=self.accept).start()</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">accept</span>(<span class="params">self</span>):</span> <span class="comment"># 多人连接</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> self.event.is_set():</span><br><span class="line">            sock, client = self.sock.accept() <span class="comment"># 阻塞</span></span><br><span class="line">            <span class="comment">#准备接收数据，recv是阻塞的，开启新的线程</span></span><br><span class="line">            f = sock.makefile(<span class="string">&#x27;rw&#x27;</span>) <span class="comment"># 支持读写</span></span><br><span class="line">            self.clients[client] = f <span class="comment"># 添加到客户端字典</span></span><br><span class="line">            threading.Thread(target=self.recv, args=(f, client), name=<span class="string">&#x27;recv&#x27;</span>).start()</span><br><span class="line">            </span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">recv</span>(<span class="params">self, f, client</span>):</span> <span class="comment"># 接收客户端数据</span></span><br><span class="line">         <span class="keyword">while</span> <span class="keyword">not</span> self.event.is_set():</span><br><span class="line">             <span class="keyword">try</span>:</span><br><span class="line">             	data = f.readline() <span class="comment"># 阻塞到换行符</span></span><br><span class="line">             <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">             	logging.error(e) <span class="comment"># 有任何异常，退出</span></span><br><span class="line">         		data = <span class="string">&#x27;quit&#x27;</span></span><br><span class="line">             msg = data.strip()</span><br><span class="line">        	<span class="comment">#客户端退出命令</span></span><br><span class="line">             <span class="keyword">if</span> msg == <span class="string">&#x27;quit&#x27;</span>:</span><br><span class="line">                 self.clients.pop(client)</span><br><span class="line">                 f.close()</span><br><span class="line">                 logging.info(<span class="string">&#x27;&#123;&#125; quits&#x27;</span>.<span class="built_in">format</span>(client))</span><br><span class="line">                 <span class="keyword">break</span></span><br><span class="line">         	msg = <span class="string">&quot;&#123;:%Y/%m/%d %H:%M:%S&#125; &#123;&#125;:&#123;&#125;\n&#123;&#125;\n&quot;</span>.<span class="built_in">format</span>(datetime.datetime.now(), *client,data)</span><br><span class="line">         	logging.info(msg)</span><br><span class="line">         </span><br><span class="line">            <span class="keyword">for</span> s <span class="keyword">in</span> self.clients.values():</span><br><span class="line">                 s.write(msg)</span><br><span class="line">                 s.flush()</span><br><span class="line">        </span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">stop</span>(<span class="params">self</span>):</span> <span class="comment"># 停止服务</span></span><br><span class="line">         <span class="keyword">for</span> s <span class="keyword">in</span> self.clients.values():</span><br><span class="line">         	s.close()</span><br><span class="line">         self.sock.close()</span><br><span class="line">         self.event.<span class="built_in">set</span>()</span><br><span class="line">            </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">     cs = ChatServer()</span><br><span class="line">     cs.start()</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">         cmd = <span class="built_in">input</span>(<span class="string">&#x27;&gt;&gt;&#x27;</span>).strip()</span><br><span class="line">         <span class="keyword">if</span> cmd == <span class="string">&#x27;quit&#x27;</span>:</span><br><span class="line">             cs.stop()</span><br><span class="line">             threading.Event().wait(<span class="number">3</span>)</span><br><span class="line">             <span class="keyword">break</span></span><br><span class="line">     	 logging.info(threading.<span class="built_in">enumerate</span>()) <span class="comment"># 用来观察断开后线程的变化</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">     main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="TCP客户端编程"><a href="#TCP客户端编程" class="headerlink" title="TCP客户端编程"></a>TCP客户端编程</h3><hr>
<p>客户端编程步骤</p>
<ul>
<li>创建Socket对象</li>
<li>连接到远端服务端的IP和PORT、connect()方法</li>
<li>传输数据<ul>
<li>使用send、recv方法发送、接收数据</li>
</ul>
</li>
<li>关闭连接、释放资源</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">client = socket.socket()</span><br><span class="line">ipaddr = (<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">9999</span>)</span><br><span class="line">client.connect(ipaddr) <span class="comment"># 直接连接服务器</span></span><br><span class="line">client.send(<span class="string">b&#x27;abcd\n&#x27;</span>)</span><br><span class="line">data = client.recv(<span class="number">1024</span>) <span class="comment"># 阻塞等待</span></span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line">client.close()</span><br></pre></td></tr></table></figure>

<p>编写聊天的客户类</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">FORMAT = <span class="string">&quot;%(asctime)s %(threadName)s %(thread)d %(message)s&quot;</span></span><br><span class="line">logging.basicConfig(<span class="built_in">format</span>=FORMAT, level=logging.INFO)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChatClient</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init</span>(<span class="params">self, ip=<span class="string">&#x27;127.0.0.1&#x27;</span>, port=<span class="number">9999</span></span>):</span></span><br><span class="line">        self.sock = socket.socket()</span><br><span class="line">        self.addr = (ip, port)</span><br><span class="line">        self.event = threading.Event()</span><br><span class="line">       </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start</span>(<span class="params">self</span>):</span> <span class="comment"># 启动对远端服务器的连接</span></span><br><span class="line">        self.sock.connect(self.addr)</span><br><span class="line">        self.send(<span class="string">&quot;I&#x27;m ready.&quot;</span>)</span><br><span class="line">		<span class="comment">#准备接收数据，recv是阻塞的，开启新的线程</span></span><br><span class="line">		threading.Thread(target=self.recv, name=<span class="string">&quot;recv&quot;</span>).start()</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recv</span>(<span class="params">self</span>):</span> <span class="comment"># 接收客户端的数据</span></span><br><span class="line">     	<span class="keyword">while</span> <span class="keyword">not</span> self.event.is_set():</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                data = self.sock.recv(<span class="number">1024</span>) <span class="comment"># 阻塞</span></span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                logging.error(e)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">     		msg = <span class="string">&quot;&#123;:%Y/%m/%d %H:%M:%S&#125; &#123;&#125;:&#123;&#125;\n&#123;&#125;\n&quot;</span>.<span class="built_in">format</span>(datetime.datetime.now(), *self.addr,data.strip())</span><br><span class="line">     		logging.info(msg)</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">send</span>(<span class="params">self, msg:<span class="built_in">str</span></span>):</span></span><br><span class="line">        data = <span class="string">&quot;&#123;&#125;\n&quot;</span>.<span class="built_in">format</span>(msg.strip()).encode() <span class="comment"># 服务端需要一个换行符</span></span><br><span class="line">        self.sock.send(data)</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">stop</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.sock.close()</span><br><span class="line">        self.event.wait(<span class="number">3</span>)</span><br><span class="line">        self.event.<span class="built_in">set</span>()</span><br><span class="line">        logging.info(<span class="string">&#x27;Client stops.&#x27;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    cc = ChatClient()</span><br><span class="line">    cc.start()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        cmd = <span class="built_in">input</span>(<span class="string">&#x27;&gt;&gt;&gt;&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> cmd.strip() == <span class="string">&#x27;quit&#x27;</span>:</span><br><span class="line">            cc.stop()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        cc.send(cmd) <span class="comment"># 发送消息</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> name == <span class="string">&#x27;main&#x27;</span>:</span><br><span class="line"> main()	</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://vampireqian.github.io/2017/11/01/16%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" data-id="ckxlw2jbn00170zexbkx5asef" data-title="网络编程" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/socket/" rel="tag">socket</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-15python反射、描述器" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2017/10/19/15python%E5%8F%8D%E5%B0%84%E3%80%81%E6%8F%8F%E8%BF%B0%E5%99%A8/" class="article-date">
  <time class="dt-published" datetime="2017-10-18T16:00:00.000Z" itemprop="datePublished">2017-10-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/python/">python</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2017/10/19/15python%E5%8F%8D%E5%B0%84%E3%80%81%E6%8F%8F%E8%BF%B0%E5%99%A8/">python-反射、描述器</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>运行时，区别于编译时，指的是程序被加载到内存中执行的时候。<br>反射，reflection，指的是运行时获取类型定义信息。<br>简单说，在Python中，能够通过一个对象，找出其type、class、attribute或method的能力，称为反射或者自省。<br>具有反射能力的函数有：type()、isinstance()、callable()、dir()、getattr()</p>
<table>
<thead>
<tr>
<th>内建函数</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>getattr(object, name[, default])</td>
<td>通过name返回object的属性值。当属性不存在，将使用default返回，如果没有default，则抛出AttributeError。name必须为字符串</td>
</tr>
<tr>
<td>setattr(object, name, value)</td>
<td>object的属性存在，则覆盖，不存在，新增</td>
</tr>
<tr>
<td>hasattr(object, name)</td>
<td>判断对象是否有这个名字的属性，name必须为字符串</td>
</tr>
</tbody></table>
<p>给一个实例用setattr添加一个方法，不做绑定，不会绑定到类中，此时不能用类调用，然而类使用setattr方法，会把那个方法绑定到类的字典上。</p>
<p>思考<br>这种动态增加属性的方式和装饰器修饰一个类、Mixin方式的差异？</p>
<p>这种动态增删属性的方式是运行时改变类或者实例的方式，但是装饰器或Mixin都是定义时就决定了，因此反射能力具有更大的灵活性。</p>
<h3 id="反射相关的魔术方法"><a href="#反射相关的魔术方法" class="headerlink" title="反射相关的魔术方法"></a>反射相关的魔术方法</h3><p><code>__getattr__()</code>、<code>__setattr__()</code>、<code>__delattr__()</code>这三个魔术方法。</p>
<table>
<thead>
<tr>
<th>魔术方法</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td><code>__getattr__()</code></td>
<td>当通过搜索实例、实例的类及祖先类查不到属性，就会调用此方法</td>
</tr>
<tr>
<td><code>__setattr__()</code></td>
<td>通过.访问实例属性，进行增加、修改都要调用它</td>
</tr>
<tr>
<td><code>__delattr__()</code></td>
<td>当通过实例来删除属性时调用此方法</td>
</tr>
<tr>
<td><code>__getattribute__()</code></td>
<td>实例所有的属性调用都从这个方法开始</td>
</tr>
</tbody></table>
<p>一个类的属性会按照继承关系找，如果找不到，就会执行<code> __getattr__()</code> 方法，如果没有这个方法，就会抛出AttributeError异常表示找不到属性。<br>查找属性顺序为：<br>实例调用<code>__getattribute__()</code> –&gt;<code> instance.__dict__</code> –&gt;<code> instance.__class__.__dict__</code> –&gt; 继承的祖先类（直到object）的<code>__dict__</code>—找不到–&gt; 调用<code>__getattr__()</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>(<span class="params">Base</span>):</span></span><br><span class="line">    z = <span class="number">6</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x, y</span>):</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(self.x, self.y)</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;missing &#123;&#125;&quot;</span>.<span class="built_in">format</span>(item)</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span>(<span class="params">self, key, value</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;setattr &#123;&#125;=&#123;&#125;&quot;</span>.<span class="built_in">format</span>(key,value))</span><br><span class="line">        self.__dict__[key] = value</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>__setattr__()</code>方法，可以拦截对实例属性的增加、修改操作，如果要设置生效，需要自己操作实例的<br><code>__dict__</code>。</p>
<p><strong><code>__getattribute__</code>方法</strong></p>
<p>实例的所有的属性访问，第一个都会调用<code>__getattribute__</code>方法，它阻止了属性的查找，该方法应该返回（计算后的）值或者抛出一个AttributeError异常。</p>
<ul>
<li>它的return值将作为属性查找的结果。</li>
<li>如果抛出AttributeError异常，则会直接调用<code>__getattr__</code>方法，因为表示属性没有找到。</li>
</ul>
<p><code>__getattribute__</code>方法中为了避免在该方法中无限的递归，它的实现应该永远调用基类的同名方法以访问需要的任何属性，例如<code>object.__getattribute__(self, name)</code>。<br>注意，除非你明确地知道<code>__getattribute__</code>方法用来做什么，否则不要使用它。</p>
<h2 id="描述器"><a href="#描述器" class="headerlink" title="描述器"></a>描述器</h2><p>描述器的表现<br>用到3个魔术方法:__get__()、__set__()、__delete__()<br>方法签名如下<br>object.__get__(self, instance, owner)<br>object.__set__(self, instance, value)<br>object.__delete__(self, instance)<br>self 指代当前实例，调用者<br>instance 是owner的实例<br>owner 是属性的所属的类</p>
<h3 id="描述器定义"><a href="#描述器定义" class="headerlink" title="描述器定义"></a>描述器定义</h3><p>Python中，一个类实现了<code>__get__</code>、<code>__set__</code>、<code>__delete__</code>三个方法中的任何一个方法，就是描述器。<br>如果仅实现了<code>__get__</code>，就是<font color=red><strong>非数据描述符 non-data descriptor</strong></font>；<br>同时实现了<code>__get__</code>、<code>__set__</code>就是<font color=red><strong>数据描述符 data descriptor</strong></font></p>
<p>如果一个类的类属性设置为描述器实例，那么它被称为owner属主。</p>
<h3 id="属性查找顺序"><a href="#属性查找顺序" class="headerlink" title="属性查找顺序"></a>属性查找顺序</h3><p>实例的<code>__dict__</code> 优先于非数据描述器<br>数据描述器优先于实例的<code>__dict__</code><br><code>__delete__</code>方法有同样的效果，有了这个方法，也是数据描述器。</p>
<h3 id="Python中的描述器"><a href="#Python中的描述器" class="headerlink" title="Python中的描述器"></a>Python中的描述器</h3><hr>
<p>Python的方法（包括staticmethod()和classmethod()）都实现为非数据描述器。因此，实例可以重新定义和覆盖方法。这允许单个实例获取与同一类的其他实例不同的行为。</p>
<p>property()函数实现为一个数据描述器。因此，实例不能覆盖属性的行为。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line"><span class="meta">    @classmethod  </span><span class="comment"># 非数据描述器</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">cls</span>):</span> </span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @staticmethod </span><span class="comment"># 非数据描述器</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span>():</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @property </span><span class="comment"># 数据描述器</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">z</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getfoo</span>(<span class="params">self</span>):</span> <span class="comment"># 非数据描述器</span></span><br><span class="line">        <span class="keyword">return</span> self.foo</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span> <span class="comment"># 非数据描述器</span></span><br><span class="line">        self.foo = <span class="number">100</span></span><br><span class="line">        self.bar = <span class="number">200</span></span><br><span class="line">        <span class="comment">#self.z = 300</span></span><br><span class="line">        </span><br><span class="line">a = A()</span><br><span class="line"><span class="built_in">print</span>(a.__dict__)</span><br><span class="line"><span class="built_in">print</span>(A.__dict__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#foo、bar都可以在实例中覆盖，但是z不可以。</span></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://vampireqian.github.io/2017/10/19/15python%E5%8F%8D%E5%B0%84%E3%80%81%E6%8F%8F%E8%BF%B0%E5%99%A8/" data-id="ckxlw2jbm00130zex2bpddiae" data-title="python-反射、描述器" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/" rel="tag">python</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-14python面向对象-特殊属性、查看属性、魔术方法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2017/10/11/14python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%89%B9%E6%AE%8A%E5%B1%9E%E6%80%A7%E3%80%81%E6%9F%A5%E7%9C%8B%E5%B1%9E%E6%80%A7%E3%80%81%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2017-10-10T16:00:00.000Z" itemprop="datePublished">2017-10-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/python/">python</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2017/10/11/14python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%89%B9%E6%AE%8A%E5%B1%9E%E6%80%A7%E3%80%81%E6%9F%A5%E7%9C%8B%E5%B1%9E%E6%80%A7%E3%80%81%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95/">python面向对象-特殊属性、查看属性、魔术方法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="特殊属性"><a href="#特殊属性" class="headerlink" title="特殊属性"></a>特殊属性</h3><table>
<thead>
<tr>
<th>属性</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>__name_</code></td>
<td>类、函数、方法等的名字</td>
</tr>
<tr>
<td><code>__module_</code></td>
<td>类定义所在的模块名</td>
</tr>
<tr>
<td><code>__class_</code></td>
<td>对象或者类所属的类</td>
</tr>
<tr>
<td><code>__bases__</code></td>
<td>类的基类的元组，顺序为它们在基类列表中出现的顺序</td>
</tr>
<tr>
<td><code>__doc__</code></td>
<td>类、函数的文档字符串，如果没有定义则为None</td>
</tr>
<tr>
<td><code>__mro__</code></td>
<td>类的mro，class.mro()返回的结果保存在<code>__mro__</code>中</td>
</tr>
<tr>
<td><code>__dict__</code></td>
<td>类的实例的属性，可写的字典</td>
</tr>
</tbody></table>
<h3 id="查看属性"><a href="#查看属性" class="headerlink" title="查看属性"></a>查看属性</h3><table>
<thead>
<tr>
<th>方法</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td><code>__dir__</code></td>
<td>返回类或者对象的所有成员名称列表。dir()函数就是调用__dir__()。 <br/>使用实例调用时，如果提供__dir__()，则返回其返回值，要求是可迭代对象。 如果没有提供__dir__()，则会从实例和类及祖先类中收集信息（尽可能多的）</td>
</tr>
</tbody></table>
<p>如果dir([obj])参数obj包含方法__dir__()，该方法将被调用。如果参数obj不包含__dir__()，该方法将最大限<br>度地收集属性信息。</p>
<p>dir(obj)对于不同类型的对象obj具有不同的行为：</p>
<ol>
<li><p>如果对象是模块对象，返回的列表包含模块的属性名和变量名。</p>
</li>
<li><p>如果对象是类或者类对象，返回的列表包含类的属性名，及它的基类的属性名。</p>
</li>
<li><p>如果obj不写，返回列表包含内容不同</p>
<ul>
<li>在模块中，返回模块的属性和变量名</li>
<li>在函数中，返回本地作用域的变量名</li>
<li>在方法中，返回本地作用域的变量名</li>
</ul>
</li>
</ol>
<h2 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a><font color=red>魔术方法</font></h2><hr>
<p>分类：</p>
<ul>
<li>创建、初始化和销毁<ul>
<li><code>__new__</code>和<code>__init__</code>和<code>__del__</code></li>
</ul>
</li>
<li>hash</li>
<li>bool</li>
<li>可视化</li>
<li>运算符重载</li>
<li>容器和大小</li>
<li>可调用对象</li>
<li>上下文管理</li>
<li>反射</li>
<li>描述器</li>
<li>其他</li>
</ul>
<h4 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h4><hr>
<table>
<thead>
<tr>
<th>方法</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td><code>__new__</code></td>
<td>实例化一个对象<br>该方法需要返回一个值(本类型的实例)，如果该值不是cls的实例，则不会调用<code>__init__</code><br>该方法永远都是静态</td>
</tr>
</tbody></table>
<p>__new__方法很少使用，即使创建了该方法，也会使用return super().__new__(cls)得到实例化对象，或者基类object的__new__方法来创建实例并返回。</p>
<h4 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h4><hr>
<table>
<thead>
<tr>
<th>方法</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td><code>__hash__</code></td>
<td>内建函数hash()调用的返回值，返回一个整数。如果定义这个方法该类的实例就可hash。</td>
</tr>
<tr>
<td><code>__eq__</code></td>
<td>对应==操作符，判断2个对象是否相等，返回bool值</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age=<span class="number">18</span></span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__hash__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.name == other.name</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hash</span>(A(<span class="string">&#x27;tom&#x27;</span>)))</span><br><span class="line"><span class="built_in">print</span>((A(<span class="string">&#x27;tom&#x27;</span>), A(<span class="string">&#x27;tom&#x27;</span>)))</span><br><span class="line"><span class="built_in">print</span>([A(<span class="string">&#x27;tom&#x27;</span>), A(<span class="string">&#x27;tom&#x27;</span>)])</span><br><span class="line"><span class="built_in">print</span>(&#123;(<span class="string">&#x27;tom&#x27;</span>,), (<span class="string">&#x27;tom&#x27;</span>,)&#125;)</span><br></pre></td></tr></table></figure>

<p>hash(x) ,x都一样，求得的hash应该是不变的，这是幂等性的缘故，一般来说，x不一样，hash应该不一样。</p>
<p>不同的hash算法，不同的x求得同样的hash值，这就是hash冲突。</p>
<hr>
<p><code>__hash__</code>方法只是返回一个hash值作为set的key，但是去重，还需要<code>__eq__</code>（等效==，就是内容相等）来判断2个对象是否相等，is判断的是内存地址，is相等的话就肯定是同一个元素。<br>hash值相等，只是hash冲突，不能说明两个对象是相等的。<br>因此，一般来说提供<code>__hash__</code>方法是为了作为set或者dict的key，所以去重要同时提供<code>__eq__</code>方法。</p>
<p>不可hash对象isinstance(p1, collections.Hashable)一定为False。<br>去重需要提供<code>__eq__</code>方法。</p>
<hr>
<p>list类实例为什么不可hash </p>
<p>源码中有一句<code>__hash__</code> = None，也就是如果调用<code>__hash__()</code>相当于None()，一定报错。<br>所有类都继承object，而这个类是具有<code>__hash__()</code>方法的，如果一个类不能被hash，就把<code>__hash__</code>设置为None。</p>
<h4 id="bool"><a href="#bool" class="headerlink" title="bool"></a>bool</h4><hr>
<table>
<thead>
<tr>
<th>方法</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td><code>__bool__</code></td>
<td>内建函数bool()，或者对象放在逻辑表达式的位置，调用这个函数返回布尔值。 定义<code>__bool__()</code>，这个函数的返回值必须要是bool类型。没有定义<code>__bool__()</code>，就找<code>__len__()</code>返回长度，非0为真。 如果<code>__len__()</code>也没有定义，那么所有实例都返回真。</td>
</tr>
</tbody></table>
<p>两个对象（类和实例）可以当作True理解。</p>
<p>等效Fals的本质是：对于四大皆空：空串，空元组。空列表，空字典，先找bool，如果没有bool就看长度，当长度为0就恒为假。</p>
<h4 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h4><hr>
<table>
<thead>
<tr>
<th>方法</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td><code>__repr__</code></td>
<td>内建函数repr()对一个对象获取字符串表达。 <br/>调用<code>__repr__</code>方法返回<strong>字符串</strong>表达，如果<code>__repr__</code>也没有定义，就直接返回object的定义，就是显示内存地址信息。</td>
</tr>
<tr>
<td><code>__str__</code></td>
<td>str()函数、format()函数、print()函数调用，需要返回对象的字符串表达。如果没有定义，就去调用<code>__repr__</code>方法返回<strong>字符串</strong>表达，如果<code>__repr__</code>没有定义，就直接返回对象的内存地址信息。</td>
</tr>
<tr>
<td><code>__bytes__</code></td>
<td>bytes()函数调用，返回一个对象的bytes表达，即返回bytes对象</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age=<span class="number">18</span></span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;repr: &#123;&#125;,&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(self.name, self.age)</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;str:  &#123;&#125;,&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(self.name, self.age)</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bytes__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment">#return &quot;&#123;&#125; is &#123;&#125;&quot;.format(self.name, self.age).encode()</span></span><br><span class="line">        <span class="keyword">import</span> json</span><br><span class="line">        <span class="keyword">return</span> json.dumps(self.__dict__).encode()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(A(<span class="string">&#x27;tom&#x27;</span>)) <span class="comment"># print函数使用__str__</span></span><br><span class="line"><span class="built_in">print</span>([A(<span class="string">&#x27;tom&#x27;</span>)]) <span class="comment"># []使用__str__，但其内部使用__repr__</span></span><br><span class="line"><span class="built_in">print</span>([<span class="built_in">str</span>(A(<span class="string">&#x27;tom&#x27;</span>))]) <span class="comment"># []使用__str__，其中的元素使用str()函数也调用__str__</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bytes</span>(A(<span class="string">&#x27;tom&#x27;</span>)))</span><br></pre></td></tr></table></figure>
<p>总结：一般首先找的是repr，当repr没有就找str，都没有就去object中去寻找。bytes方法转成二进制只是一种序列化的表达，和序列化还是有差别的，序列化是一种通用的二进制格式或者通用的中间格式，序列化是一种交互，转化成文本传输的，而这里的转换只是一种表达，给人展示用的。</p>
<blockquote>
<p>注意不能通过判断是否带引号来判断输出值的类型，类型判断要使用type或isinstance</p>
</blockquote>
<h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><hr>
<p>operator模块提供了以下特殊方法，可以将类的实例使用下面的操作符来操作</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>特殊方法</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;, &lt;=, ==, &gt;, &gt;=, !=</td>
<td><code>__lt__</code>, <code>__le__</code>, <code>__eq__</code>, <code>__gt__</code>, <code>__ge__</code>, <code>__ne__</code></td>
<td>比较运算符</td>
</tr>
<tr>
<td>+, -, *, /, %, //,**, divmod</td>
<td><code>__add__</code>, <code>__sub__</code>, <code>__mul__</code>, <code>__truediv__</code>, <code>__mod__</code>, <code>__floordiv__</code>, <code>__pow__</code>, <code>__divmod__</code></td>
<td>算数运算符</td>
</tr>
<tr>
<td>+=, -=, *=, /=, %=, //=, **=</td>
<td><code>__iadd__</code>, <code>__isub__</code>, <code>__imul__</code>, <code>__itruediv__</code>, <code>__imod__, __ifloordiv__</code>,<code> __ipow__</code></td>
<td></td>
</tr>
</tbody></table>
<h4 id="functools-total-ordering-装饰器"><a href="#functools-total-ordering-装饰器" class="headerlink" title="@functools.total_ordering 装饰器"></a>@functools.total_ordering 装饰器</h4><p>__lt__, __le__, __eq__, __gt__, __ge__是比较大小必须实现的方法，但是全部写完太麻烦，使用<br>@functools.total_ordering 装饰器就可以大大简化代码。</p>
<p>但是要求__eq__必须实现，其它方法__lt__, __le__, __gt__, __ge__  实现其一。</p>
<p>但是：</p>
<p>__eq__等于可以推断不等于<br>__gt__大于可以推断小于<br>__ge__大于等于可以推断小于等于<br>也就是用3个方法，就可以把所有比较解决了，所以total_ordering可以不使用</p>
<h3 id="容器相关方法"><a href="#容器相关方法" class="headerlink" title="容器相关方法"></a>容器相关方法</h3><hr>
<table>
<thead>
<tr>
<th>方法</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td><code>__len__</code></td>
<td>内建函数len()，返回对象的长度（&gt;=0的整数），如果把对象当做容器类型看，就如同list或者dict。bool()函数调用的时候，如果没有__bool__()方法，则会看__len__()方法是否存在，存在返回非0为真。</td>
</tr>
<tr>
<td><code>__iter__</code></td>
<td>迭代容器时，调用，返回一个新的迭代器对象</td>
</tr>
<tr>
<td><code>__contains__</code></td>
<td>in 成员运算符，没有实现，就调用<code>__iter__</code>方法遍历</td>
</tr>
<tr>
<td><code>__getitem__</code></td>
<td>实现self[key]访问。序列对象，key接受整数为索引，或者切片。对于set和dict，key为hashable。key不存在引发KeyError异常</td>
</tr>
<tr>
<td><code>__setitem__</code></td>
<td>和<code>__getitem__</code>的访问类似，是设置值的方法</td>
</tr>
<tr>
<td><code>__missing__</code></td>
<td>字典或其子类使用<code>__getitem__</code>()调用时，key不存在执行该方法</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>(<span class="params"><span class="built_in">dict</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__missing__</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Missing key : &#x27;</span>, key)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"> </span><br><span class="line">a = A()</span><br><span class="line"><span class="built_in">print</span>(a[<span class="string">&#x27;k&#x27;</span>])</span><br></pre></td></tr></table></figure>

<h3 id="可调用对象"><a href="#可调用对象" class="headerlink" title="可调用对象"></a>可调用对象</h3><hr>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(foo.__module__, foo.__name__)</span><br><span class="line"> </span><br><span class="line">foo()</span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line">foo.__call__()</span><br></pre></td></tr></table></figure>

<p>函数即对象，对象foo加上()，就是调用此函数对象的<code>__call__</code>()方法。</p>
<p><strong>可调用对象</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td><code>__call__</code></td>
<td>类中定义一个方法，实例就可以像函数一样调用</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x, y</span>):</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&lt;Point &#123;&#125;:&#123;&#125;&gt;&quot;</span>.<span class="built_in">format</span>(self.x, self.y)</span><br><span class="line"> </span><br><span class="line">p = Point(<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(p)</span><br><span class="line"><span class="built_in">print</span>(p())</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adder</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, *args</span>):</span></span><br><span class="line">        ret = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> args:</span><br><span class="line">            ret += x</span><br><span class="line">        self.ret = ret</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"> </span><br><span class="line">adder = Adder()</span><br><span class="line"><span class="built_in">print</span>(adder(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>))</span><br><span class="line"><span class="built_in">print</span>(adder.ret)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#&lt;__main__.Point object at 0x000002D5F04C2198&gt;</span></span><br><span class="line"><span class="comment">#&lt;Point 4:5&gt;</span></span><br><span class="line"><span class="comment">#15</span></span><br><span class="line"><span class="comment">#15</span></span><br></pre></td></tr></table></figure>

<p>练习:</p>
<p>定义一个斐波那契数列的类，方便调用，计算第n项</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fib</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.items = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, index</span>):</span></span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> IndexError(<span class="string">&#x27;Wrong Index&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="built_in">len</span>(self.items):</span><br><span class="line">            <span class="keyword">return</span> self.items[index]</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, index+<span class="number">1</span>):</span><br><span class="line">            self.items.append(self.items[i-<span class="number">1</span>] + self.items[i-<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">return</span> self.items[index]</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(Fib()(<span class="number">100</span>))</span><br></pre></td></tr></table></figure>

<p>上例中，增加迭代的方法、返回容器长度、支持索引的方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fib</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.items = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, index</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self[index]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iter</span>(self.items)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.items)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, index</span>):</span></span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> IndexError(<span class="string">&quot;Wrong Index&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="built_in">len</span>(self.items):</span><br><span class="line">            <span class="keyword">return</span> self.items[index]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self), index + <span class="number">1</span>):</span><br><span class="line">            self.items.append(self.items[i - <span class="number">1</span>] + self.items[i - <span class="number">2</span>])</span><br><span class="line">        <span class="keyword">return</span> self.items[index]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(self.items)</span><br><span class="line"></span><br><span class="line">    __repr__ = __str__</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fib = Fib()</span><br><span class="line"><span class="built_in">print</span>(fib(<span class="number">5</span>), <span class="built_in">len</span>(fib))  <span class="comment"># 全部计算</span></span><br><span class="line"><span class="built_in">print</span>(fib(<span class="number">10</span>), <span class="built_in">len</span>(fib))  <span class="comment"># 部分计算</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;------&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> fib:</span><br><span class="line">    <span class="built_in">print</span>(x, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"><span class="built_in">print</span>(fib[<span class="number">5</span>], fib[<span class="number">9</span>])  <span class="comment"># 索引访问，不计算</span></span><br></pre></td></tr></table></figure>

<h3 id="上下文管理对象"><a href="#上下文管理对象" class="headerlink" title="上下文管理对象"></a>上下文管理对象</h3><hr>
<p>当一个对象同时实现了<code>__enter__</code>（）和<code>__exit__</code>（）方法，它就属于上下文管理的对象。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td><code>__enter__</code></td>
<td>进入与此对象相关的上下文。如果存在该方法，with语法会把该方法的返回值作为绑定到as子句中指定的变量上</td>
</tr>
<tr>
<td><code>__exit__</code></td>
<td>退出与此对象相关的上下文。</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;init&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;enter&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span>(<span class="params">self, exc_type, exc_val, exc_tb</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;exit&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> Point() <span class="keyword">as</span> f:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-&quot;</span> * <span class="number">30</span>)</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=====end=======&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>实例化对象的时候，并不会调用enter，进入with语句块调用__enter__方法，然后执行语句体，最后离开with语句块的时候，调用__exit__方法。</p>
<p>with可以开启一个上下文运行环境，在执行前做一些准备工作，执行后做一些收尾工作。<br>注意，with并不开启一个新的作用域。</p>
<p>上下文管理很安全，不管是碰到异常都还是会正常执行</p>
<p><code>__enter__</code>方法返回值就是上下文中使用的对象，with语法会把它的返回值赋给as子句的变量。</p>
<h4 id="方法的参数"><a href="#方法的参数" class="headerlink" title="方法的参数"></a>方法的参数</h4><hr>
<p><code>__enter__</code>方法 没有其他参数。<br><code>__exit__</code>方法有3个参数：<br><code>__exit__</code>(self, exc_type, exc_value, traceback)<br>这三个参数都与异常有关。<br>如果该上下文退出时没有异常，这3个参数都为None。<br>如果有异常，参数意义如下<br>exc_type，异常类型<br>exc_value，异常的值<br>traceback，异常的追踪信息<br><code>__exit__</code>方法返回一个等效True的值，则压制异常；否则，继续抛出异常</p>
<h4 id="上下文应用场景"><a href="#上下文应用场景" class="headerlink" title="上下文应用场景"></a>上下文应用场景</h4><hr>
<ol>
<li>增强功能<br> 在代码执行的前后增加代码，以增强其功能。类似装饰器的功能。</li>
<li>资源管理<br> 打开了资源需要关闭，例如文件对象、网络连接、数据库连接等</li>
<li>权限验证<br> 在执行代码之前，做权限的验证，在<code>__enter__</code>中处理</li>
</ol>
<h4 id="contextlib-contextmanager"><a href="#contextlib-contextmanager" class="headerlink" title="contextlib.contextmanager"></a>contextlib.contextmanager</h4><hr>
<p>contextlib.contextmanager<br>它是一个装饰器实现上下文管理，装饰一个函数，而不用像类一样实现__enter__和__exit__方法。<br>对下面的函数有要求，必须有yield，也就是这个函数必须返回一个生成器，且只有yield一个值。<br>也就是这个装饰器接收一个生成器对象作为参数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> contextlib</span><br><span class="line"></span><br><span class="line"><span class="meta">@contextlib.contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sub</span>(<span class="params">x, y</span>):</span>  <span class="comment"># 为生成器函数增加了上下文管理</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;enter&quot;</span>)</span><br><span class="line">    start = datetime.datetime.now()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">yield</span> x - y  <span class="comment"># yield的值只能有一个，作为__enter__方法的返回值</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        detla = (datetime.datetime.now() - start).total_seconds()</span><br><span class="line">        <span class="built_in">print</span>(detla)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;exit&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> sub(<span class="number">6</span>, <span class="number">2</span>) <span class="keyword">as</span> f:</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;------------&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(f)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;~~~~~~~~~~&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line">enter</span><br><span class="line">------------</span><br><span class="line"><span class="number">4</span></span><br><span class="line">~~~~~~~~~~</span><br><span class="line"><span class="number">2.000654</span></span><br><span class="line">exit</span><br></pre></td></tr></table></figure>

<p>当yield发生处为生成器函数增加了上下文管理。这是为函数增加上下文机制的方式。</p>
<ul>
<li>把yield之前的当做__enter__方法执行</li>
<li>把yield之后的当做__exit__方法执行</li>
<li>把yield的值作为__enter__的返回值</li>
</ul>
<hr>
<p>总结 :<br>如果业务逻辑简单可以使用函数加contextlib.contextmanager装饰器方式，如果业务复杂，用类的方式加__enter__和__exit__方法方便。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://vampireqian.github.io/2017/10/11/14python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%89%B9%E6%AE%8A%E5%B1%9E%E6%80%A7%E3%80%81%E6%9F%A5%E7%9C%8B%E5%B1%9E%E6%80%A7%E3%80%81%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95/" data-id="ckxlw2jbk00100zex4vfx48tl" data-title="python面向对象-特殊属性、查看属性、魔术方法" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/" rel="tag">python</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-13python面向对象基础" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2017/10/01/13python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/" class="article-date">
  <time class="dt-published" datetime="2017-09-30T16:00:00.000Z" itemprop="datePublished">2017-10-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/python/">python</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2017/10/01/13python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/">python-面向对象</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><hr>
<p>一种认识世界，分析世界的方法论。将万事万物抽象为类</p>
<p>类class</p>
<p>类是抽象的概念，是万事万物的抽象，是一类事物的共同特征的集合。用计算机语言来描述就是<strong>属性</strong>和<strong>方法</strong>的集合（封装）。</p>
<p>对象instance、object，对象是类的具象，是一个实体，类也是对象。</p>
<p>属性，它是对象状态的抽象，用数据结构来描述。</p>
<p>操作，是对对象行为的抽象，用操作名和实现该操作的方法来描述。</p>
<p><strong>哲学</strong></p>
<p>一切皆对象</p>
<p>对象是数据和操作的封装</p>
<p>对象是独立的，但是对象之间可以相互作用</p>
<p>目前OOP是最接近人类认知的编程范式</p>
<h4 id="面向对象三要素"><a href="#面向对象三要素" class="headerlink" title="面向对象三要素"></a>面向对象三要素</h4><p><font color = red><strong>封装</strong></font>：将属性和方法组装到一起，隐藏数据，对外只暴露一些接口用于连接。</p>
<p><font color = red><strong>继承</strong></font>：目的：多复用，继承来的就不用自己写了；多继承少修改（开闭原则），OCP(open_closed principle)，使用继承来改变。作用：就是为了修改不一样的属性。</p>
<p><font color = red><strong>多态</strong></font>：面向对象编程最灵活的地方，多种表现，动态绑定。</p>
<h4 id="Python的类"><a href="#Python的类" class="headerlink" title="Python的类"></a>Python的类</h4><p>定义：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span>：</span></span><br><span class="line"><span class="class">	语句块</span></span><br></pre></td></tr></table></figure>

<p><strong>要求：</strong></p>
<ol>
<li><p>必须使用class关键字</p>
</li>
<li><p>类名必须使用大驼峰命名</p>
</li>
<li><p>类定义完成后会产生一个类对象，会绑定到ClassName这个标识符上面。</p>
</li>
</ol>
<h4 id="类对象和类属性"><a href="#类对象和类属性" class="headerlink" title="类对象和类属性"></a>类对象和类属性</h4><p><font color = red><strong>类对象</strong></font>，类的定义就会生成一个类对象</p>
<p><font color = red><strong>类的属性</strong></font>，类定义中的变量和类中定义的方法都是类的属性</p>
<p><font color = red><strong>类变量</strong></font>，定义在类中的变量</p>
<h4 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h4><p>在类对象名称后面加上一个括号，就调用类的实例化方法，完成实例化，实例化就真正创建一个该类的对象（实例）。</p>
<p>每一次实例化，只能生成该类的一个具体实例，生成的是不同的实例。即使通过相同的参数实例化，得到的对象也不相同。</p>
<p>python类实例化后，会自动调用<code>__init__</code>方法，可以不定义，如果没有定义会在实例化后<strong>隐式</strong>调用，初始化函数可以有多个参数，第一参数必须留给self，init方法不能有返回值，也就是只能有return None</p>
<p>作用：对实例进行<font color = red><strong>初始化</strong></font></p>
<p>类里面的函数叫做方法对象method，不是普通的函数对象function，一般至少要有一个参数，第一个参数可以是self（一般习惯上用self），这个参数位置指代的就是当前这个实例本身。</p>
<h4 id="实例对象instance"><a href="#实例对象instance" class="headerlink" title="实例对象instance"></a>实例对象instance</h4><p>类实例化后一定会获得一个对象，就是<font color = red><strong>实例对象</strong></font>。init方法的第一个参数self就是指代某一个实例。</p>
<h4 id="实例变量和类变量"><a href="#实例变量和类变量" class="headerlink" title="实例变量和类变量"></a>实例变量和类变量</h4><p>实例变量是每个实例自己的变量，是自己独有的；列变量是类的变量，是类的所有实例共享的属性和方法。</p>
<table>
<thead>
<tr>
<th>特殊属性</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>_<em>name</em>_</td>
<td>对象名</td>
</tr>
<tr>
<td>_<em>class</em>_</td>
<td>对象的类型</td>
</tr>
<tr>
<td>_<em>dict</em>_</td>
<td>对象的属性的字典</td>
</tr>
<tr>
<td>_<em>qualname</em>_</td>
<td>类的限定名</td>
</tr>
</tbody></table>
<p>类属性保存在类的dict中，实例属性保存在实例的dict中，如果从实例访问类的属性，就要借助class找到所属的类。</p>
<p>类有类名字，实例没有实体名。</p>
<p>python中每一种对象都拥有不同的属性。函数、类都是对象，类的实例也是对象。</p>
<p>类不可以访问实例的属性，实例可以访问类的属性。（是类的，也是这个类所有实例的，其实例都可以访问到；是实例的，就是这个实例自己的，通过类访问不到。）</p>
<p>对象（实例或类）可以动态的给自己增加一个属性，实例._<em>dict</em>_[变量名]可以访问到，实例的同名变量会隐藏掉类变量，或者说是覆盖了这个类的变量。</p>
<p>一般来说，属性使用字典保存是为了提升查找效率，必须用空间换时间，但是也有个问题，如果数百万个对象，那么字典占的比较大，所以可以使用__slots__方法。</p>
<p>slots告诉解释器，实例的属性都叫什么，一般来说，既然要节省内存，那就最好还是使用元组。</p>
<p>一旦类提供了slots，就阻止实例产生dict来保存实例的属性。子类不会继承slots</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    X = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    __slots__ = (<span class="string">&#x27;z&#x27;</span>,<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.y = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(self.X,self.y)</span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">a.show()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;A&quot;</span>,A.__dict__.keys())</span><br><span class="line"><span class="comment"># print(&quot;obj&quot;,a.__dict__.keys())</span></span><br></pre></td></tr></table></figure>

<p><font color = red>**实例属性的查找顺序 **</font><br>指的是实例使用.点号来访问属性，会先找实例自己的__dict__，如果没有，然后通过属性__class__找到自己的类，再去类的__dict__中找类属性中没找到就往类继承的父类中去查找，最终找到根基类object，没找到则抛出异常 。<br>注意，如果实例使用__dict__[变量名]访问变量，将不会按照上面的查找顺序找变量了，这是指明使用字典的key查找，不是属性查找。<br>一般来说，类变量可使用全大写来命名。</p>
<h4 id="装饰一个类"><a href="#装饰一个类" class="headerlink" title="装饰一个类"></a>装饰一个类</h4><p>为一个类通过装饰，添加一些类属性。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#增加类变量</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">adda_name</span>(<span class="params">name,cls</span>):</span></span><br><span class="line">    cls.NAME = name  <span class="comment">#动态增加类属性</span></span><br><span class="line"><span class="comment">#改进成装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_name</span>(<span class="params">name</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">cls</span>):</span></span><br><span class="line">        cls.NAME = name</span><br><span class="line">        <span class="keyword">return</span> cls</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"><span class="meta">@add_name(<span class="params"><span class="string">&quot;jerry&quot;</span></span>)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>():</span>  <span class="comment">#Person =  add_name(&quot;jerry&quot;)(Person) = wrapper(person) =  Person</span></span><br><span class="line">    AGE = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># adda_name(Person ,&quot;tom&quot;)</span></span><br><span class="line">	</span><br><span class="line"><span class="built_in">print</span>(Person.__dict__)</span><br><span class="line"><span class="built_in">print</span>(Person.NAME)</span><br></pre></td></tr></table></figure>

<p>之所以能够装饰，本质上是为类对象动态的添加了一个属性，而Person这个标识符指向这个类对象。</p>
<hr>
<h4 id="类方法和静态方法"><a href="#类方法和静态方法" class="headerlink" title="类方法和静态方法"></a>类方法和静态方法</h4><p>类方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">class_method</span>(<span class="params">cls</span>):</span> <span class="comment"># cls是什么</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;class = &#123;0.__name__&#125; (&#123;0&#125;)&#x27;</span>.<span class="built_in">format</span>(cls))</span><br><span class="line">        cls.HEIGHT = <span class="number">170</span></span><br><span class="line"> </span><br><span class="line">Person.class_method()</span><br><span class="line"><span class="built_in">print</span>(Person.__dict__)</span><br></pre></td></tr></table></figure>
<p>类方法</p>
<ol>
<li><p>在类定义中，使用@classmethod装饰器修饰的方法，不管使用实例还是类来调用，调用的都是类的方法，传入当前类自身。</p>
</li>
<li><p>必须至少有一个参数，且第一个参数留给了cls，cls指代调用者即<font color = red><strong>类对象自身</strong></font></p>
</li>
<li><p>cls这个标识符可以是任意合法名称，但是为了易读，请不要修改</p>
</li>
<li><p>通过cls可以直接操作类的属性</p>
</li>
</ol>
<p>静态方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method</span>(<span class="params">self,name</span>)： #普通方法</span></span><br><span class="line"><span class="function">    	<span class="title">print</span>(<span class="params">self</span>)</span></span><br><span class="line"><span class="function">   </span></span><br><span class="line"><span class="function">    @<span class="title">classmethod</span>   #类方法</span></span><br><span class="line"><span class="function">    <span class="title">def</span> <span class="title">class_method</span>(<span class="params">cls ， age</span>):</span>  <span class="comment"># cls是什么  是当前类</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;class = &#123;0.__name__&#125; (&#123;0&#125;)&#x27;</span>.<span class="built_in">format</span>(cls))</span><br><span class="line">        cls.HEIGHT = <span class="number">170</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod  </span><span class="comment">#静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">static_methd</span>(<span class="params">a</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(Person.HEIGHT , a)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">Person.method(Person(),<span class="string">&quot;ken&quot;</span>)  <span class="comment">#第一参数不会自动传入，自己传Person（）</span></span><br><span class="line">Person().method(<span class="string">&quot;tom&quot;</span>)  <span class="comment">#第一参数自动传入Person（）</span></span><br><span class="line"></span><br><span class="line">Person.class_method(<span class="number">20</span>)  <span class="comment">#第一参数cls自动传入</span></span><br><span class="line">Person().method(<span class="number">18</span>)  <span class="comment">#第一参数cls自动传入</span></span><br><span class="line"></span><br><span class="line">Person.static_methd()   <span class="comment">#第一参数不用传</span></span><br><span class="line">Person().static_method()  <span class="comment">#第一参数不用传</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Person.__dict__)</span><br></pre></td></tr></table></figure>

<p>静态方法</p>
<ol>
<li>在类定义中，使用@staticmethod装饰器修饰的方法</li>
<li>调用时，不管是实例还是类调用，不会隐式的传入参数 。<br> 静态方法，只是表明这个方法属于这个名词空间。函数归在一起，方便组织管理。</li>
</ol>
<p>总结：<br>类除了普通方法都可以调用，普通方法需要对象的实例作为第一参数。<br>实例可以调用所有类中定义的方法（包括类方法、静态方法），普通方法传入实例自身，静态方法和类方法需要找到实例的类。</p>
<p>实例方法</p>
<p>如果用实例，第一参数则传入self，则叫做绑定。如果使用类调用，则没有绑定（未绑定行为）。</p>
<h4 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h4><h5 id="私有-Private-属性"><a href="#私有-Private-属性" class="headerlink" title="私有(Private)属性"></a>私有(Private)属性</h5><p>使用双下划线开头的属性名，就是私有属性</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age=<span class="number">18</span></span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.__age = age</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">growup</span>(<span class="params">self, i=<span class="number">1</span></span>):</span></span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> i &lt; <span class="number">150</span>: <span class="comment"># 控制逻辑</span></span><br><span class="line">            self.__age += i</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getage</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.__age</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(Person(<span class="string">&#x27;tom&#x27;</span>).getage())</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>私有变量的本质：<br>类定义的时候，如果声明一个实例变量的时候，使用双下划线，Python解释器会将其改名，转换名称为<strong>_类名__变量名</strong>的名称，所以用原来的名字访问不到了。</p>
<h5 id="保护变量"><a href="#保护变量" class="headerlink" title="保护变量"></a>保护变量</h5><p>在变量名前使用一个下划线，称为保护变量。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age=<span class="number">18</span></span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self._age = age</span><br><span class="line"> </span><br><span class="line">tom = Person(<span class="string">&#x27;Tom&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(tom._age)</span><br><span class="line"><span class="built_in">print</span>(tom.__dict__)</span><br></pre></td></tr></table></figure>
<p>可以看出，这个_age属性根本就没有改变名称，和普通的属性一样，解释器不做任何特殊处理。 这只是开发者共同的约定，看见这种变量，就如同私有变量，不要直接使用。</p>
<h5 id="私有方法"><a href="#私有方法" class="headerlink" title="私有方法"></a>私有方法</h5><p>参照保护变量、私有变量，使用单下划线、双下划线命名方法。</p>
<p>私有方法的本质 </p>
<p>单下划线的方法只是开发者之间的约定，解释器不做任何改变。 </p>
<p>双下划线的方法，是私有方法，解释器会改名，改名策略和私有变量相同，**_类名__方法名 <strong>。<br>方法变量都在类的</strong>__dict__**中可以找到。</p>
<p>私有成员的总结 :</p>
<p>在Python中使用_单下划线或者 __ 双下划线来标识一个成员被保护或者被私有化隐藏起来。<br>但是，不管使用什么样的访问控制，都不能真正的阻止用户修改类的成员。Python中没有绝对的安全的保护成员或者私有成员。<br>因此，前导的下划线只是一种警告或者提醒，请遵守这个约定。除非真有必要，不要修改或者使用保护成员或者私有成员，更不要修改它们。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age=<span class="number">18</span></span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self._age = age</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_getname</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getage</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._age</span><br><span class="line"> </span><br><span class="line">tom = Person(<span class="string">&#x27;Tom&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(tom._getname()) <span class="comment"># 没改名</span></span><br><span class="line"><span class="built_in">print</span>(tom.__getage()) <span class="comment"># 无此属性</span></span><br><span class="line"><span class="built_in">print</span>(tom.__dict__)</span><br><span class="line"><span class="built_in">print</span>(tom.__class__.__dict__)</span><br><span class="line"><span class="built_in">print</span>(tom._Person__getage()) <span class="comment"># 改名了</span></span><br></pre></td></tr></table></figure>

<h4 id="补丁"><a href="#补丁" class="headerlink" title="补丁"></a>补丁</h4><p>可以通过修改或者替换类的成员。使用者调用的方式没有改变，但是，类提供的功能可能已经改变了。</p>
<p>猴子补丁（Monkey Patch）：<br>在运行时，对属性、方法、函数等进行动态替换。<br>其目的往往是为了通过替换、修改来增强、扩展原有代码的能力。<br>黑魔法，慎用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test1.py</span></span><br><span class="line"><span class="keyword">from</span> test2 <span class="keyword">import</span> Person</span><br><span class="line"><span class="keyword">from</span> test3 <span class="keyword">import</span> get_score</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">monkeypatch4Person</span>():</span></span><br><span class="line">    Person.get_score = get_score</span><br><span class="line"> </span><br><span class="line">monkeypatch4Person() <span class="comment"># 打补丁</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(Person().get_score())</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test2.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_score</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># connect to mysql</span></span><br><span class="line">        ret = &#123;<span class="string">&#x27;English&#x27;</span>:<span class="number">78</span>, <span class="string">&#x27;Chinese&#x27;</span>:<span class="number">86</span>, <span class="string">&#x27;History&#x27;</span>:<span class="number">82</span>&#125;</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test3.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_score</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dict</span>(name=self.__class__.__name__,English=<span class="number">88</span>, Chinese=<span class="number">90</span>, History=<span class="number">85</span>)</span><br></pre></td></tr></table></figure>

<p>上例中，假设Person类get_score方法是从数据库拿数据，但是测试的时候，不方便。<br>为了测试时方便，使用猴子补丁，替换了get_score方法，返回模拟的数据。</p>
<h4 id="属性装饰器"><a href="#属性装饰器" class="headerlink" title="属性装饰器"></a>属性装饰器</h4><p>一般好的设计是：把实例的属性保护起来，不让外部直接访问，外部使用getter读取属性和setter方法设置属性。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age=<span class="number">18</span></span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.__age = age</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.__age</span><br><span class="line"></span><br><span class="line"><span class="meta">    @age.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span>(<span class="params">self, age</span>):</span></span><br><span class="line">        self.__age = age</span><br><span class="line"></span><br><span class="line"><span class="meta">    @age.deleter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># del self.__age</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;del&#x27;</span>)</span><br><span class="line"></span><br><span class="line">tom = Person(<span class="string">&#x27;Tom&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(tom.age)</span><br><span class="line">tom.age = <span class="number">20</span></span><br><span class="line"><span class="built_in">print</span>(tom.age)</span><br><span class="line"><span class="keyword">del</span> tom.age</span><br></pre></td></tr></table></figure>

<p>特别注意：使用property装饰器的时候这三个方法<strong>同名</strong><br>property装饰器<br>后面跟的函数名就是以后的属性名。它就是getter。这个必须有，有了它至少是只读属性</p>
<p>setter装饰器<br>与属性名同名，且接收2个参数，第一个是self，第二个是将要赋值的值。有了它，属性可写</p>
<p>deleter装饰器<br>可以控制是否删除属性。很少用</p>
<p>property装饰器必须在前，setter、deleter装饰器在后。<br>property装饰器能通过简单的方式，把对方法的操作变成对属性的访问，并起到了一定隐藏效果.</p>
<h4 id="对象的销毁"><a href="#对象的销毁" class="headerlink" title="对象的销毁"></a>对象的销毁</h4><p>类中可以定义 __del__ 方法，称为析构函数（方法）。</p>
<p>作用：销毁类的实例的时候调用，以释放占用的资源。其中就放些清理资源的代码，比如释放连接。</p>
<p>注意这个方法不能引起对象的真正销毁，只是对象销毁的时候会自动调用它。</p>
<p>使用del语句删除实例，引用计数减1。当引用计数为0时，会自动调用__del__ 方法。<br>由于Python实现了垃圾回收机制，不能确定对象何时执行垃圾回收。</p>
<p>由于垃圾回收对象销毁时，才会真正清理对象，还会在回收对象之前自动调用__del__ 方法，除非你明确知道自己的目的，建议不要手动调用这个方法。</p>
<h4 id="方法重载-overload"><a href="#方法重载-overload" class="headerlink" title="方法重载(overload)"></a>方法重载(overload)</h4><p>其他面向对象的高级语言中，会有重载的概念。<br>所谓重载，就是同一个方法名，但是参数数量、类型不一样，就是同一个方法的重载。</p>
<p>Python没有重载！<br>Python不需要重载！<br>Python中，方法（函数）定义中，形参非常灵活，不需要指定类型（就算指定了也只是一个说明而非约束），参数个数也不固定（可变参数）。一个函数的定义可以实现很多种不同形式实参的调用。所以Python不需要方法的重载。</p>
<p>或者说Python本身就实现了其它语言的重载。</p>
<h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>面向对象的三要素之一，封装Encapsulation</p>
<p>将数据和操作组织到类中，即属性和方法 </p>
<p>将数据隐藏起来，给使用者提供操作（方法）。使用者通过操作就可以获取或者修改数据。getter和setter。 </p>
<p>通过访问控制，暴露适当的数据和操作给用户，该隐藏的隐藏起来，例如保护成员或私有成员。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://vampireqian.github.io/2017/10/01/13python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/" data-id="ckxlw2jbj000v0zex8ny15734" data-title="python-面向对象" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/" rel="tag">python</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-12python直接赋值、深拷贝和浅拷贝" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2017/09/30/12python%E7%9B%B4%E6%8E%A5%E8%B5%8B%E5%80%BC%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/" class="article-date">
  <time class="dt-published" datetime="2017-09-30T12:15:17.000Z" itemprop="datePublished">2017-09-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/python/">python</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2017/09/30/12python%E7%9B%B4%E6%8E%A5%E8%B5%8B%E5%80%BC%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/">python直接赋值、深拷贝和浅拷贝</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>python中，对象赋值实际上是对象的引用。当创建一个对象，将其赋值给另一个变量，python并没有拷贝这个对象，而是拷贝了这个对象的引用。 所以如果从单纯的赋值语句来实现clone对象的话， 那可能bug出现的也会莫名其妙. Python中可以使用copy模块来复制对象.</p>
<p>copy.copy 为浅拷贝, 只copy父对象， 不会拷贝对象内部的子对象 copy.deepcopy 深拷贝, 拷贝对象及其子对象</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> copy</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a                    <span class="comment"># 赋值拷贝</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = copy.copy(a)         <span class="comment"># 浅拷贝, 只拷贝了a的引用, 内部元素没有拷贝.</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = copy.deepcopy(a)     <span class="comment"># 深拷贝, 完全拷贝</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.append(<span class="number">5</span>)       </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">4</span>].append(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> <span class="string">&#x27;a=&#x27;</span>,a</span><br><span class="line">a= [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> <span class="string">&#x27;b=&#x27;</span>,b</span><br><span class="line">b= [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], <span class="number">5</span>]   <span class="comment">#赋值拷贝, 内存地址指向一样的。 相当于一个人的两个名字而已.</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> <span class="string">&#x27;c=&#x27;</span>,c</span><br><span class="line">c= [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]]      <span class="comment">#浅拷贝, 子元素c[4]引用的地址和a[4]是一样的. 所以改变a[4]相当于改了c[4].</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> <span class="string">&#x27;d=&#x27;</span>,d</span><br><span class="line">d= [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]]           <span class="comment">#深拷贝完全拷贝. a和d完全改变了.</span></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://vampireqian.github.io/2017/09/30/12python%E7%9B%B4%E6%8E%A5%E8%B5%8B%E5%80%BC%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/" data-id="ckxlw2jbj000t0zex3a881m6m" data-title="python直接赋值、深拷贝和浅拷贝" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/" rel="tag">python</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-11python异常处理、模块化" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2017/09/22/11python%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E3%80%81%E6%A8%A1%E5%9D%97%E5%8C%96/" class="article-date">
  <time class="dt-published" datetime="2017-09-21T16:00:00.000Z" itemprop="datePublished">2017-09-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/python/">python</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2017/09/22/11python%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E3%80%81%E6%A8%A1%E5%9D%97%E5%8C%96/">python-异常处理、模块化</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="异常Exception"><a href="#异常Exception" class="headerlink" title="异常Exception"></a>异常Exception</h3><hr>
<p><strong>错误 Error</strong> ：错误是可以避免的<br>逻辑错误：算法写错了，加法写成了减法<br>笔误：变量名写错了，语法错误<br>函数或类使用错误，其实这也属于逻辑错误 </p>
<p><strong>异常 Exception</strong> ：异常不可能避免<br>本意就是意外情况<br>这有个前提，没有出现上面说的错误，也就是说程序写的没有问题，但是在某些情况下，会出现一些意外，导致程序无法正常的执行下去。<br>例如open函数操作一个文件，文件不存在，或者创建一个文件时已经存在了，或者访问一个网络文件，突然断网了，这就是异常，是个意外的情况。 </p>
<p><strong>错误和异常</strong><br>在高级编程语言中，一般都有错误和异常的概念，异常是可以捕获，并被处理的，但是错误是不能被捕获的。</p>
<h3 id="产生异常"><a href="#产生异常" class="headerlink" title="产生异常"></a>产生异常</h3><hr>
<p>产生：</p>
<ul>
<li>raise 语句显式的抛出异常</li>
<li>Python解释器自己检测到异常并引发它</li>
</ul>
<p>程序会在异常抛出的地方中断执行，如果不捕获，就会提前结束程序（其实是终止当前线程的执行）</p>
<p><strong>raise语句</strong><br>raise后什么都没有，表示抛出<strong>最近一个被激活</strong>的异常，如果没有，则抛类型异常。这种方式很少用 。</p>
<p>raise后要求应该是BaseException类的子类或实例，如果是类，将被无参实例化。</p>
<h3 id="异常类及继承层次"><a href="#异常类及继承层次" class="headerlink" title="异常类及继承层次"></a>异常类及继承层次</h3><hr>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python异常的继承</span></span><br><span class="line"> </span><br><span class="line">BaseException</span><br><span class="line"> +-- SystemExit</span><br><span class="line"> +-- KeyboardInterrupt</span><br><span class="line"> +-- GeneratorExit</span><br><span class="line"> +-- Exception</span><br><span class="line">      +-- RuntimeError</span><br><span class="line">      |    +-- RecursionError</span><br><span class="line">      +-- MemoryError</span><br><span class="line">      +-- NameError</span><br><span class="line">      +-- StopIteration</span><br><span class="line">      +-- StopAsyncIteration</span><br><span class="line">      +-- ArithmeticError</span><br><span class="line">      |    +-- FloatingPointError</span><br><span class="line">      |    +-- OverflowError</span><br><span class="line">      |    +-- ZeroDivisionError</span><br><span class="line">      +-- LookupError</span><br><span class="line">      |    +-- IndexError</span><br><span class="line">      |    +-- KeyError</span><br><span class="line">      +-- SyntaxError</span><br><span class="line">      +-- OSError</span><br><span class="line">      |    +-- BlockingIOError</span><br><span class="line">      |    +-- ChildProcessError</span><br><span class="line">      |    +-- ConnectionError</span><br><span class="line">      |    |    +-- BrokenPipeError</span><br><span class="line">      |    |    +-- ConnectionAbortedError</span><br><span class="line">      |    |    +-- ConnectionRefusedError</span><br><span class="line">      |    |    +-- ConnectionResetError</span><br><span class="line">      |    +-- FileExistsError</span><br><span class="line">      |    +-- FileNotFoundError</span><br><span class="line">      |    +-- InterruptedError</span><br><span class="line">      |    +-- IsADirectoryError</span><br><span class="line">      |    +-- NotADirectoryError</span><br><span class="line">      |    +-- PermissionError</span><br><span class="line">      |    +-- ProcessLookupError</span><br><span class="line">      |    +-- TimeoutError</span><br></pre></td></tr></table></figure>

<h3 id="BaseException及子类"><a href="#BaseException及子类" class="headerlink" title="BaseException及子类"></a>BaseException及子类</h3><hr>
<p><strong>BaseException</strong><br>所有内建异常类的基类是BaseException</p>
<p><strong>SystemExit</strong><br>sys.exit(n)函数引发的异常，异常不捕获处理，就直接交给Python解释器，解释器退出。n=0,正常退出，n=1异常退出。</p>
<p>如果except语句捕获了该异常，则继续向后面执行，如果没有捕获住该异常SystemExit，解释器直接退出程序。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;before&#x27;</span>)</span><br><span class="line">sys.exit(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;SysExit&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;outer&#x27;</span>) <span class="comment"># 不执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 捕获这个异常</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    sys.exit(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">except</span> SystemExit: <span class="comment"># 换成Exception</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;SysExit&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;outer&#x27;</span>) <span class="comment"># 执行</span></span><br></pre></td></tr></table></figure>

<p><strong>KeyboardInterrupt</strong><br>对应的捕获用户中断行为Ctrl + C</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">import</span> time</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;ctl + c&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;outer&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="Exception及子类"><a href="#Exception及子类" class="headerlink" title="Exception及子类"></a>Exception及子类</h3><p><strong>Exception</strong>是所有内建的、非系统退出的异常的基类，自定义异常应该继承自它</p>
<p><strong>SyntaxError</strong> 语法错误<br>Python将这种错误也归到异常类下面的Exception下的子类，但是这种错误是不可捕获的</p>
<p><strong>ArithmeticError</strong> 所有算术计算引发的异常，其子类有除零异常等</p>
<p><strong>LookupError</strong><br>使用映射的键或序列的索引无效时引发的异常的基类：IndexError, KeyError</p>
<p><strong>自定义异常</strong><br>从Exception继承的类</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span>(<span class="params">Exception</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">raise</span> MyException()</span><br><span class="line"><span class="keyword">except</span> MyException: <span class="comment"># 捕获自定义异常</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;catch the exception&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="未实现和未实现异常"><a href="#未实现和未实现异常" class="headerlink" title="未实现和未实现异常"></a>未实现和未实现异常</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="literal">NotImplemented</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(NotImplementedError))</span><br><span class="line"></span><br><span class="line"><span class="comment">#&lt;class &#x27;NotImplementedType&#x27;&gt;</span></span><br><span class="line"><span class="comment">#&lt;class &#x27;type&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<p>NotImplemented是个值，单值，是NotImplementedType的实例</p>
<p>NotImplementedError是类型，是异常，返回type</p>
<h3 id="异常的捕获"><a href="#异常的捕获" class="headerlink" title="异常的捕获"></a>异常的捕获</h3><hr>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    待捕获异常的代码块</span><br><span class="line"><span class="keyword">except</span> [异常类型]:</span><br><span class="line">    异常的处理代码块</span><br></pre></td></tr></table></figure>

<p>使用了<strong>try…except语句</strong>块捕捉到了这个异常，异常生成位置之后语句将不再执行，转而执行对应的except部分的语句，最后执行try…except语句块之外的语句。</p>
<p>except 后接异常类型，用来捕获指定类型的异常，except可以捕获多个异常。</p>
<p>捕获规则<br>捕获是从上到下依次比较，如果匹配，则执行匹配的except语句块<br>如果被一个except语句捕获，其他except语句就不会再次捕获了<br>如果没有任何一个except语句捕获到这个异常，则该异常向外抛出</p>
<p>捕获的原则<br>从小到大，从具体到宽泛</p>
<p>被抛出的异常，应该是异常的实例，使用as子句接收这个抛出的异常。</p>
<h3 id="finally子句"><a href="#finally子句" class="headerlink" title="finally子句"></a>finally子句</h3><hr>
<p>finally<br>最终，即最后一定要执行的，try…finally语句块中，不管是否发生了异常，都要执行finally的部分</p>
<p>finally中一般放置资源的清理、释放工作的语句，也可以在finally中再次捕捉异常。</p>
<h3 id="异常的传递"><a href="#异常的传递" class="headerlink" title="异常的传递"></a>异常的传递</h3><hr>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo1</span>():</span></span><br><span class="line">​    <span class="keyword">return</span> <span class="number">1</span>/<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo2</span>():</span></span><br><span class="line">​    <span class="built_in">print</span>(<span class="string">&#x27;foo2 start&#x27;</span>)</span><br><span class="line">​    foo1()</span><br><span class="line">​    <span class="built_in">print</span>(<span class="string">&#x27;foo2 stop&#x27;</span>)</span><br><span class="line"></span><br><span class="line">foo2()</span><br></pre></td></tr></table></figure>
<p>foo2调用了foo1，foo1产生的异常，传递到了foo2中。<br>异常总是向外层抛出，如果外层没有处理这个异常，就会继续向外抛出<br>如果内层捕获并处理了异常，外部就不能捕获到了<br>如果到了最外层还是没有被处理，就会中断异常所在的线程的执行。注意整个程序结束的状态返回值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 线程中测试异常</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo1</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>/<span class="number">0</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo2</span>():</span></span><br><span class="line">    time.sleep(<span class="number">3</span>) <span class="comment"># 3秒后抛出异常</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;foo2 start&#x27;</span>)</span><br><span class="line">    foo1()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;foo2 stop&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">t = threading.Thread(target=foo2)</span><br><span class="line">t.start()</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Everything OK&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> t.is_alive():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;alive&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;dead&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>




<h3 id="try嵌套"><a href="#try嵌套" class="headerlink" title="try嵌套"></a>try嵌套</h3><hr>
<p>内部捕获不到异常，会向外层传递异常<br>但是如果内层有finally且其中有return、break语句，则异常就不会继续向外抛出：异常被压制。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        ret = <span class="number">1</span> / <span class="number">0</span></span><br><span class="line">    <span class="keyword">except</span> KeyError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(e)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;inner fin&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;outer catch&#x27;</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;outer fin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出    </span></span><br><span class="line"><span class="comment">#inner fin</span></span><br><span class="line"><span class="comment">#outer catch</span></span><br><span class="line"><span class="comment">#outer fin</span></span><br></pre></td></tr></table></figure>

<h3 id="异常的捕获的时机"><a href="#异常的捕获的时机" class="headerlink" title="异常的捕获的时机"></a>异常的捕获的时机</h3><p>1.立即捕获</p>
<p>需要立即返回一个明确的结果</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_int</span>(<span class="params">s</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(s)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(parse_int(<span class="string">&#x27;s&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>2.边界捕获</p>
<p>封装产生了边界</p>
<p>例如，写了一个模块，用户调用这个模块的时候捕获异常，模块内部不需要捕获、处理异常，一旦内部处理了，外<br>部调用者就无法感知了。<br>例如，open函数，出现的异常交给调用者处理，文件存在了，就不用再创建了，看是否修改还是删除<br>例如，自己写了一个类，使用了open函数，但是出现了异常不知道如何处理，就继续向外层抛出，一般来说最外<br>层也是边界，必须处理这个异常了，否则线程退出</p>
<h3 id="else子句"><a href="#else子句" class="headerlink" title="else子句"></a>else子句</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    ret = <span class="number">1</span> * <span class="number">0</span></span><br><span class="line"><span class="keyword">except</span> ArithmeticError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;OK&#x27;</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;fin&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>else子句<br><strong>没有任何异常发生</strong>，则执行</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><hr>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    &lt;语句&gt;    <span class="comment">#运行别的代码</span></span><br><span class="line"><span class="keyword">except</span> &lt;异常类&gt;：</span><br><span class="line">    &lt;语句&gt;    <span class="comment"># 捕获某种类型的异常</span></span><br><span class="line"><span class="keyword">except</span> &lt;异常类&gt; <span class="keyword">as</span> &lt;变量名&gt;:</span><br><span class="line">    &lt;语句&gt;    <span class="comment"># 捕获某种类型的异常并获得对象</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    &lt;语句&gt;    <span class="comment">#如果没有异常发生</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    &lt;语句&gt;    <span class="comment">#退出try时总会执行</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>try的工作原理</strong> </p>
<p>1、如果try中语句执行时发生异常，搜索except子句，并执行第一个匹配该异常的except子句<br>2、如果try中语句执行时发生异常，却没有匹配的except子句，异常将被递交到外层的try，如果外层不处理这个异常，异常将继续向外层传递。如果都不处理该异常，则会传递到最外层，如果还没有处理，就终止异常所在的线程<br>3、如果在try执行时没有发生异常，将执行else子句中的语句<br>4、无论try中是否发生异常，finally子句最终都会执行。</p>
<h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>Python中只有一种模块对象类型，但是为了模块化组织模块的便利，提供了“包”的概念。模块module，指的是Python的源代码文件。</p>
<p>包package，指的是模块组织在一起的和包名同名的目录及其相关文件。</p>
<h3 id="导入语句"><a href="#导入语句" class="headerlink" title="导入语句"></a>导入语句</h3><table>
<thead>
<tr>
<th>语句</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>import 模块1，[模块2….]</td>
<td>完全导入</td>
</tr>
<tr>
<td>import….as…..</td>
<td>模块别名</td>
</tr>
</tbody></table>
<p><strong>import语句</strong></p>
<p>1、找到指定的模块，加载和初始化它，生成模块对象。找不到，抛出ImportError</p>
<p>2、在import所在的作用域的局部命名空间中，增加名称和上一步创建的对象关联。</p>
<p><strong>总结</strong></p>
<p>导入顶级模块，其名称会加入到本地名词空间中，并绑定到其模块对象。</p>
<p>导入非顶层模块，只将其顶级模块名称加入到本地名称空间中。导入的模块必须使用完全限定名称来访问。</p>
<p>如果使用了as，as后的名称直接绑定到导入的模块对象，并将该名称加入到本地名词空间中。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://vampireqian.github.io/2017/09/22/11python%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E3%80%81%E6%A8%A1%E5%9D%97%E5%8C%96/" data-id="ckxlw2jbi000o0zexdq0o9cm0" data-title="python-异常处理、模块化" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/" rel="tag">python</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-09python文件处理、路径处理、序列化和反序列化" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2017/09/10/09python%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E3%80%81%E8%B7%AF%E5%BE%84%E5%A4%84%E7%90%86%E3%80%81%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" class="article-date">
  <time class="dt-published" datetime="2017-09-09T16:00:00.000Z" itemprop="datePublished">2017-09-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/python/">python</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2017/09/10/09python%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E3%80%81%E8%B7%AF%E5%BE%84%E5%A4%84%E7%90%86%E3%80%81%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/">python-文件处理、路径处理、序列化和反序列化</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="文件IO常用操作"><a href="#文件IO常用操作" class="headerlink" title="文件IO常用操作"></a>文件IO常用操作</h4><p>一般说IO操作，指的是文件IO。</p>
<p>把文件存储到磁盘上的这个过程，叫做落地。</p>
<table>
<thead>
<tr>
<th align="center">column</th>
<th align="center">column</th>
</tr>
</thead>
<tbody><tr>
<td align="center">open</td>
<td align="center">打开</td>
</tr>
<tr>
<td align="center">read</td>
<td align="center">读取</td>
</tr>
<tr>
<td align="center">write</td>
<td align="center">写入</td>
</tr>
<tr>
<td align="center">close</td>
<td align="center">关闭</td>
</tr>
<tr>
<td align="center">readline</td>
<td align="center">行读取</td>
</tr>
<tr>
<td align="center">readlines</td>
<td align="center">多行读取</td>
</tr>
<tr>
<td align="center">seek</td>
<td align="center">文件指针操作</td>
</tr>
<tr>
<td align="center">tell</td>
<td align="center">指针位置</td>
</tr>
</tbody></table>
<h5 id="open打开操作"><a href="#open打开操作" class="headerlink" title="open打开操作"></a>open打开操作</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">open</span>(file, mode=<span class="string">&#x27;r&#x27;</span>, buffering=-<span class="number">1</span>, encoding=<span class="literal">None</span>, errors=<span class="literal">None</span>, newline=<span class="literal">None</span>, closefd=<span class="literal">True</span>,opener=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;file名字&quot;</span>)   <span class="comment">#文件对象</span></span><br><span class="line"><span class="built_in">print</span>(f.read())		<span class="comment">#读取文件</span></span><br><span class="line">f.close()		<span class="comment">#关闭文件</span></span><br></pre></td></tr></table></figure>

<p>打开一个文件，返回一个文件对象(流对象)和文件描述符。打开文件失败，则返回异常。<br>基本使用： 创建一个文件test，然后打开它，用完关闭。</p>
<p>文件操作中最常用的就是读和写。文件访问的模式有两种：文本模式和二进制模式。</p>
<blockquote>
<p>注：windows中使用codepage代码页。可以认为每一个代码页就是一张编码表 cp936和gbk等价。</p>
</blockquote>
<h5 id="mode模式"><a href="#mode模式" class="headerlink" title="mode模式"></a>mode模式</h5><table>
<thead>
<tr>
<th>描述字符</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>缺省的，表示只读打开</td>
</tr>
<tr>
<td>w</td>
<td>只写打开，有的话就清除重新写</td>
</tr>
<tr>
<td>x</td>
<td>创建并写入一个新文件</td>
</tr>
<tr>
<td>a</td>
<td>写入打开，如果文件存在，则追加</td>
</tr>
<tr>
<td>b</td>
<td>二进制模式</td>
</tr>
<tr>
<td>t</td>
<td>缺省的，文本模式</td>
</tr>
<tr>
<td>+</td>
<td>读写打开一个文件，给原来只读、只写的增加缺失的功能</td>
</tr>
</tbody></table>
<p>open默认是只读模式r打开已经存在的文件。</p>
<ul>
<li><p>r 只读打开文件，如果使用write方法，会抛异常。 如果文件不存在，抛出FileNotFoundError异常。</p>
</li>
<li><p>w 表示只写方式打开，如果读取则抛出异常 如果文件不存在，则直接创建文件 如果文件存在，则清空文件内容。</p>
</li>
<li><p>x 文件不存在，创建文件，并只写方式打开，文件存在，抛出FileExistsError异常。</p>
</li>
<li><p>a 文件存在，只写打开，追加内容 文件不存在，则创建后，只写打开，追加内容</p>
</li>
<li><p>r是只读，wxa都是只写。 wxa都可以产生新文件，w不管文件存在与否，都会生成全新内容的文件；a不管文件是否存在，都能在打开的文件尾部追加；x必须要求文件事先不存在，自己造一个新文件。</p>
</li>
<li><p>+为r、w、a、x提供缺失的读或写功能，但是，获取文件对象依旧按照r、w、a、x自己的特征。 +不能单独使用，可以认为它是为前面的模式字符做增强功能的。</p>
</li>
</ul>
<p>t和b：</p>
<ul>
<li><p>文本模式t 字符流，将文件的字节按照某种字符编码理解，按照字符操作。open的默认mode就是rt。</p>
</li>
<li><p>二进制模式b 字节流，将文件就按照字节理解，与字符编码无关。二进制模式操作时，字节操作使用bytes类型。</p>
</li>
</ul>
<p>t/b不能单独存在，要和a/w/x/r配合使用。</p>
<h5 id="seek文件指针"><a href="#seek文件指针" class="headerlink" title="seek文件指针"></a>seek文件指针</h5><p>文件指针，指向当前字节位置。</p>
<p>mode = r，指针起始在0  ，mode  =  a  指针起始在EOF。</p>
<p>tell（）：显示指针当前位置。</p>
<p>seek(offset[, whence]) 移动文件指针位置。offest偏移多少字节，whence从哪里开始。</p>
<ul>
<li><p>文本模式下 whence 0 缺省值，表示从头开始，offset只能正整数 whence 1 表示从当前位置，offset只接受0，whence 2 表示从EOF开始，offest只接受0</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文本模式</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;test4&#x27;</span>,<span class="string">&#x27;r+&#x27;</span>)</span><br><span class="line">f.tell() <span class="comment"># 起始</span></span><br><span class="line">f.read()</span><br><span class="line">f.tell() <span class="comment"># EOF</span></span><br><span class="line">f.seek(<span class="number">0</span>) <span class="comment"># 起始</span></span><br><span class="line">f.read()</span><br><span class="line">f.seek(<span class="number">2</span>,<span class="number">0</span>)</span><br><span class="line">f.read()</span><br><span class="line">f.seek(<span class="number">2</span>,<span class="number">0</span>)</span><br><span class="line">f.seek(<span class="number">2</span>,<span class="number">1</span>) <span class="comment"># offset必须为0</span></span><br><span class="line">f.seek(<span class="number">2</span>,<span class="number">2</span>) <span class="comment"># offset必须为0</span></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure></li>
<li><p>二进制模式下 whence 0 缺省值，表示从头开始，offest只能正整数 whence 1表示从当前位置，offest可正可负，whence 2 表示从EOF开始，offest可正可负。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 二进制模式</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;test4&#x27;</span>,<span class="string">&#x27;rb+&#x27;</span>)</span><br><span class="line">f.tell() <span class="comment"># 起始</span></span><br><span class="line">f.read()</span><br><span class="line">f.tell() <span class="comment"># EOF</span></span><br><span class="line">f.write(<span class="string">b&#x27;abc&#x27;</span>)</span><br><span class="line">f.seek(<span class="number">0</span>) <span class="comment"># 起始</span></span><br><span class="line">f.seek(<span class="number">2</span>,<span class="number">1</span>) <span class="comment"># 从当前指针开始，向后2</span></span><br><span class="line">f.read()</span><br><span class="line"> </span><br><span class="line">f.seek(-<span class="number">2</span>,<span class="number">2</span>) <span class="comment"># 从EOF开始，向前2</span></span><br><span class="line">f.read()</span><br><span class="line">f.seek(-<span class="number">20</span>,<span class="number">2</span>) <span class="comment"># OSError</span></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure></li>
<li><p>二进制模式支持任意起点的偏移，从头、从尾、从中间位置开始。 向后seek可以超界，但是向前seek的时候，不能超界，否则抛异常。</p>
</li>
</ul>
<h5 id="buffering缓冲区"><a href="#buffering缓冲区" class="headerlink" title="buffering缓冲区"></a>buffering缓冲区</h5><p>-1 表示使用缺省大小的buffer。如果是二进制模式，使io.DEFAULT_BUFFER_SIZE值，默认是<font color= red>4096或者8192</font>。如果是文本模式，如果是终端设备，是行缓存方式，如果不是，则使用二进制模式的策略。</p>
<ul>
<li>0 只在二进制模式使用，表示关buffer</li>
<li>1 只在文本模式使用，表示使用行缓冲。意思就是见到换行符就flush</li>
<li>大于1 用于指定buffer的大小</li>
</ul>
<p>buffer 缓冲区 </p>
<p>缓冲区一个内存空间，一般来说是一个FIFO队列，到缓冲区满了或者达到阈值，数据才会flush到磁盘。</p>
<p>flush() 将缓冲区数据写入磁盘 close() 关闭前会调用flush()。</p>
<p>io.DEFAULT_BUFFER_SIZE 缺省缓冲区大小，字节。</p>
<table>
<thead>
<tr>
<th>buffering</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>buffering = -1</td>
<td>t和b，都是io.DEFAULT_BUFFER_SIZE</td>
</tr>
<tr>
<td>buffering = 0</td>
<td>b 关闭缓冲区 <br/>t 不支持</td>
</tr>
<tr>
<td>buffering = 1</td>
<td>b 就一个字节<br/>t 行缓冲，遇到换行符才flush</td>
</tr>
<tr>
<td>buffering &gt; 1</td>
<td>b模式表示行缓冲大小。缓冲区的值可以超过io.DEFAULT_BUFFER_SIZE，直到设定的值超出后才把缓冲区flush 。</td>
</tr>
<tr>
<td>t模式，是io.DEFAULT_BUFFER_SIZE字节，flush完后把当前字符串也写入磁盘</td>
<td></td>
</tr>
</tbody></table>
<p>一般来说：</p>
<ol>
<li>文本模式，一般都用默认缓冲区大小</li>
<li>二进制模式，是一个个字节的操作，可以指定buffer的大小</li>
<li>一般来说，默认缓冲区大小是个比较好的选择，除非明确知道，否则不调整它</li>
<li>一般编程中，明确知道需要写磁盘了，都会手动调用一次flush，而不是等到自动flush或者close的时候</li>
</ol>
<h5 id="其他参数"><a href="#其他参数" class="headerlink" title="其他参数"></a>其他参数</h5><p>编码：windows下缺省GBK（0xB0A1），Linux下缺省UTF-8（0xE5 95 8A）</p>
<p>errors ：编码错误将被捕获 None和strict表示有编码错误将抛出ValueError异常；ignore表示忽略</p>
<p>newline：文本模式中，换行的转换。可以为None、’’ 空串、’\r’、’\n’、’\r\n’ 。</p>
<ul>
<li>None表示’\r’、’\n’、’\r\n’都被转换为’\n’；</li>
<li>‘’  表示不会自动转换通用换行符；其它合法字符表示换行符就是指定字符，就会按照指定字符分行写。</li>
<li>‘\n’或’’表示’\n’不替换；其它合法字符表示’\n’会被替换为指定的字符</li>
</ul>
<p>closefd：关闭文件描述符，True表示关闭它。False会在文件关闭后保持这个描述符。fileobj.fileno()查看。</p>
<p><strong>文件描述符</strong>：Linux一切皆文件，文件打开后都会有一个位于的文件描述符，在计算机系统中是一个有限的资源。0,1,2,标准输入，标准输出，标准错误输出。</p>
<p>对于类似于文件对象的IO对象，一般来说都需要在不使用的时候关闭、注销，以释放资源。<br>IO被打开的时候，会获得一个文件描述符。计算机资源是有限的，所以操作系统都会做限制。就是为了保护计算机的资源不要被完全耗尽，计算资源是共享的，不是独占的。 </p>
<p>一般情况下，除非特别明确的知道资源情况，否则不要提高资源的限制值来解决问题。</p>
<h5 id="read（）"><a href="#read（）" class="headerlink" title="read（）"></a>read（）</h5><p>read(size=-1)<br>size表示读取的多少个字符或字节；负数或者None表示读取到EOF</p>
<p>readline(size=-1)<br>一行行读取文件内容。size设置一次能读取行内几个字符或字节。</p>
<p>readlines(hint=-1)<br>读取所有行的列表。指定hint则返回指定的行数。</p>
<h5 id="write（）"><a href="#write（）" class="headerlink" title="write（）"></a>write（）</h5><p>write(s)，把字符串s写入到文件中并返回字符的个数 writelines(lines)，将字符串列表写入文件。</p>
<h5 id="close（）"><a href="#close（）" class="headerlink" title="close（）"></a>close（）</h5><p>flush并关闭文件对象。<br>文件已经关闭，再次关闭没有任何效果。</p>
<h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>seekable（）</td>
<td>是否可seek</td>
</tr>
<tr>
<td>readable（）</td>
<td>是否可读</td>
</tr>
<tr>
<td>writeable（）</td>
<td>是否可写</td>
</tr>
<tr>
<td>closed（）</td>
<td>是否已经关闭</td>
</tr>
</tbody></table>
<h5 id="上下文管理"><a href="#上下文管理" class="headerlink" title="上下文管理"></a>上下文管理</h5><p>1、异常处理<br>当出现异常的时候，拦截异常。但是，因为很多代码都可能出现OSError异常，还不好判断异常就是应为资源限制产生的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f.write(<span class="string">&quot;abc&quot;</span>) <span class="comment"># 文件只读，写入失败</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    f.close() <span class="comment"># 这样才行</span></span><br></pre></td></tr></table></figure>

<p>使用finally可以保证打开的文件可以被关闭。</p>
<p>上下文管理</p>
<ol>
<li><p>使用with … as 关键字</p>
</li>
<li><p>上下文管理的语句块并不会开启新的作用域</p>
</li>
<li><p>with语句块执行完的时候，会自动关闭文件对象</p>
</li>
</ol>
<h4 id="StringIO操作"><a href="#StringIO操作" class="headerlink" title="StringIO操作"></a>StringIO操作</h4><p>io模块中的类</p>
<pre><code>from io import StringIO
</code></pre>
<p>内存中，开辟的一个文本模式的buffer，可以像文件对象一样操作它</p>
<p>当close方法被调用的时候，这个buffer会被释放</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> StringIO</span><br><span class="line"><span class="comment"># 内存中构建</span></span><br><span class="line">sio = StringIO() <span class="comment"># 像文件对象一样操作</span></span><br><span class="line"><span class="built_in">print</span>(sio.readable(), sio.writable(), sio.seekable())<span class="comment"># True True True</span></span><br><span class="line">sio.write(<span class="string">&quot;luo\nPython&quot;</span>)</span><br><span class="line">sio.seek(<span class="number">0</span>)  </span><br><span class="line"><span class="built_in">print</span>(sio.readline())  <span class="comment">#magedu</span></span><br><span class="line"><span class="built_in">print</span>(sio.getvalue()) <span class="comment"># 无视指针，输出全部内容  magedu   Python</span></span><br><span class="line">sio.close()</span><br></pre></td></tr></table></figure>

<p>好处</p>
<pre><code>一般来说，磁盘的操作比内存的操作要慢得多，内存足够的情况下，一般的思路是少落地，减少磁盘IO的过程，可以大大的提高程序的运行效率。
</code></pre>
<h4 id="BytesIO操作"><a href="#BytesIO操作" class="headerlink" title="BytesIO操作"></a>BytesIO操作</h4><p>io模块中的类</p>
<pre><code>from io import BytesIO
</code></pre>
<p>内存中，开辟的一个二进制模式的buffer，可以像文件对象一样操作它</p>
<p>当close方法被调用的时候，这个buffer会被释放</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO <span class="comment"># 内存中构建</span></span><br><span class="line">bio = BytesIO()</span><br><span class="line"><span class="built_in">print</span>(bio.readable(), bio.writable(), bio.seekable()) <span class="comment">#True True True</span></span><br><span class="line">bio.write(<span class="string">b&quot;luo\nPython&quot;</span>)</span><br><span class="line">bio.seek(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(bio.readline())  <span class="comment"># b&#x27;magedu\n&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(bio.getvalue()) <span class="comment"># 无视指针，输出全部内容   b&#x27;magedu\nPython&#x27;</span></span><br><span class="line">bio.close()</span><br></pre></td></tr></table></figure>

<h4 id="file-like对象"><a href="#file-like对象" class="headerlink" title="file-like对象"></a>file-like对象</h4><p>类文件对象，可以像文件对象一样操作。</p>
<p>socket对象，输入输出对象（stdin、stdout）都是类文件对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> stdout, stderr</span><br><span class="line">f = stdout</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(f))  <span class="comment">#&lt;class &#x27;ipykernel.iostream.OutStream&#x27;&gt;</span></span><br><span class="line">f.write(<span class="string">&#x27;magedu.com&#x27;</span>)  <span class="comment">#magedu.com</span></span><br></pre></td></tr></table></figure>

<h4 id="路径操作"><a href="#路径操作" class="headerlink" title="路径操作"></a>路径操作</h4><h5 id="os-path模块"><a href="#os-path模块" class="headerlink" title="os.path模块"></a>os.path模块</h5><p>3.4版本之前</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> path</span><br><span class="line">p = path.join(<span class="string">&#x27;d:/&#x27;</span>,<span class="string">&#x27;tmp&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(p), p)               <span class="comment">#&lt;class &#x27;str&#x27;&gt; d:/tmp</span></span><br><span class="line"><span class="built_in">print</span>(path.exists(p))     <span class="comment">#判断是否存在该路径  True</span></span><br><span class="line"><span class="built_in">print</span>(path.split(p)) <span class="comment"># (head,tail)     (&#x27;d:/&#x27;, &#x27;tmp&#x27;)</span></span><br><span class="line"><span class="built_in">print</span>(path.abspath(<span class="string">&#x27;.&#x27;</span>))   <span class="comment"># 打印当前的绝对路径      C:\Users\vampire\python</span></span><br><span class="line">p = path.join(<span class="string">&#x27;D:/&#x27;</span>, p, <span class="string">&#x27;test.txt&#x27;</span>)   <span class="comment">#  &#x27;d:/tmp\\test.txt&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(path.dirname(p)) <span class="comment"># 目录名</span></span><br><span class="line"><span class="built_in">print</span>(path.basename(p)) <span class="comment">#基名，就是文件名</span></span><br><span class="line"><span class="built_in">print</span>(path.splitdrive(p)) <span class="comment">#二元组  (&#x27;d:&#x27;, &#x27;/tmp\\test.txt&#x27;）</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">p1 = path.abspath(<span class="string">&quot;.&quot;</span>)  <span class="comment">#“文件路径”</span></span><br><span class="line"><span class="built_in">print</span>(p1, path.basename(p1))</span><br><span class="line"><span class="keyword">while</span> p1 != path.dirname(p1):</span><br><span class="line">    p1 = path.dirname(p1)</span><br><span class="line">    <span class="built_in">print</span>(p1, path.basename(p1))</span><br><span class="line"></span><br><span class="line">​```</span><br><span class="line">C:\Users\vampire\python python</span><br><span class="line">C:\Users\vampire vampire</span><br><span class="line">C:\Users Users</span><br><span class="line">C:\ </span><br><span class="line">​```</span><br></pre></td></tr></table></figure>

<h5 id="pathlib模块"><a href="#pathlib模块" class="headerlink" title="pathlib模块"></a>pathlib模块</h5><p>提供Path对象来操作。包括目录和文件。</p>
<p>导入模块：from pathlib import Path</p>
<p><strong>目录操作初始化</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p = Path() <span class="comment"># 当前目录    WindowsPath(&#x27;.&#x27;)</span></span><br><span class="line">p.absolute()<span class="comment">#   WindowsPath(&#x27;C:/Users/vampire/python&#x27;)</span></span><br><span class="line">p = Path(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c/d&#x27;</span>) <span class="comment"># 当前目录下的 WindowsPath(&#x27;C:/Users/vampire/python/a/b/c/d&#x27;)</span></span><br><span class="line">p = Path(<span class="string">&#x27;/etc&#x27;</span>) <span class="comment"># 根下的etc目录</span></span><br></pre></td></tr></table></figure>

<p><strong>路径拼接和分解</strong></p>
<h6 id="操作符"><a href="#操作符" class="headerlink" title="操作符/"></a>操作符/</h6><p>Path对象 / Path对象<br>Path对象 / 字符串 或者 字符串 / Path对象 </p>
<h6 id="分解"><a href="#分解" class="headerlink" title="分解"></a>分解</h6><p>parts属性，可以返回路径中的每一个部分 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p3.absolute()   <span class="comment">#WindowsPath(&#x27;C:/Users/vampire/python/c/a&#x27;)</span></span><br><span class="line">p3.absolute().parts   <span class="comment">#(&#x27;C:\\&#x27;, &#x27;Users&#x27;, &#x27;vampire&#x27;, &#x27;python&#x27;, &#x27;c&#x27;, &#x27;a&#x27;)</span></span><br></pre></td></tr></table></figure>

<h6 id="joinpath"><a href="#joinpath" class="headerlink" title="joinpath"></a>joinpath</h6><p>joinpath(*other) 连接多个字符串到Path对象中</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">p = Path()   <span class="comment">#   WindowsPath(&#x27;.&#x27;)</span></span><br><span class="line">p = p / <span class="string">&#x27;a&#x27;</span>   <span class="comment">#  WindowsPath(&#x27;a&#x27;)</span></span><br><span class="line">p.absolute()  <span class="comment">#   WindowsPath(&#x27;C:/Users/vampire/python/a&#x27;)</span></span><br><span class="line">p1 = <span class="string">&#x27;b&#x27;</span> / p  <span class="comment">#   WindowsPath(&#x27;C:/Users/vampire/python/b/a&#x27;)</span></span><br><span class="line">p2 = Path(<span class="string">&#x27;c&#x27;</span>) <span class="comment">#  WindowsPath(&#x27;C:/Users/vampire/python/c&#x27;)</span></span><br><span class="line">p2.absolute()  <span class="comment">#   WindowsPath(&#x27;C:/Users/vampire/python/c&#x27;)</span></span><br><span class="line">p3 = p2 / p1  <span class="comment">#  WindowsPath(&#x27;c/b/a&#x27;)</span></span><br><span class="line">p3.absolute()  <span class="comment">#  WindowsPath(&#x27;C:/Users/vampire/python/c/b/a&#x27;)</span></span><br><span class="line"><span class="built_in">print</span>(p3.parts)   <span class="comment">#</span></span><br><span class="line">p3.absolute().parts <span class="comment"># (&#x27;C:\\&#x27;, &#x27;Users&#x27;, &#x27;vampire&#x27;, &#x27;python&#x27;, &#x27;c&#x27;, &#x27;b&#x27;, &#x27;a&#x27;)</span></span><br><span class="line">p3.joinpath(<span class="string">&#x27;etc&#x27;</span>,<span class="string">&#x27;init.d&#x27;</span>,Path(<span class="string">&#x27;httpd&#x27;</span>))</span><br></pre></td></tr></table></figure>

<h6 id="获取路径"><a href="#获取路径" class="headerlink" title="获取路径"></a>获取路径</h6><p>str 获取路径字符串 </p>
<p>bytes 获取路径字符串的bytes </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p = Path(<span class="string">&#x27;/etc&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(p), <span class="built_in">bytes</span>(p))</span><br><span class="line"></span><br><span class="line"><span class="comment">#  \etc   b&#x27;\\etc&#x27;</span></span><br></pre></td></tr></table></figure>

<h6 id="父目录"><a href="#父目录" class="headerlink" title="父目录"></a>父目录</h6><p>parent 目录的逻辑父目录 </p>
<p>parents 父目录序列，索引0是直接的父 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">p = Path(<span class="string">&#x27;/a/b/c/d&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(p.absolute())   <span class="comment">#C:\a\b\c\d</span></span><br><span class="line"><span class="built_in">print</span>(p.parent.parent)  <span class="comment">#\a\b</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> p.parents:</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line">    </span><br><span class="line"><span class="comment">#\a\b\c</span></span><br><span class="line"><span class="comment">#\a\b</span></span><br><span class="line"><span class="comment">#\a</span></span><br><span class="line"><span class="comment">#\</span></span><br></pre></td></tr></table></figure>

<h6 id="目录的组合部分"><a href="#目录的组合部分" class="headerlink" title="目录的组合部分"></a>目录的组合部分</h6><p>name、stem、suffix、suffixes、with_suffix(suffix)、with_name(name) </p>
<p>name 目录的最后一个部分 </p>
<p>suffix 目录中最后一个部分的扩展名 </p>
<p>stem 目录最后一个部分，没有后缀 </p>
<p>suffixes 返回多个扩展名列表 </p>
<p>with_suffix(suffix) 有扩展名则替换，无则补充扩展名 </p>
<p>with_name(name) 替换目录最后一个部分并返回一个新的路径</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">p = Path(<span class="string">&#x27;mysqlinstall/mysql.tar.gz&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(p.name)   <span class="comment">#mysql.tar.gz</span></span><br><span class="line"><span class="built_in">print</span>(p.suffix)  <span class="comment">#.gz</span></span><br><span class="line"><span class="built_in">print</span>(p.suffixes)  <span class="comment"># [&#x27;.tar&#x27;, &#x27;.gz&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(p.stem)   <span class="comment"># mysql.tar</span></span><br><span class="line"><span class="built_in">print</span>(p.with_name(<span class="string">&#x27;mysql-5.tgz&#x27;</span>))   <span class="comment">#\mysqlinstall\mysql-5.tgz</span></span><br><span class="line"><span class="built_in">print</span>(p.with_suffix(<span class="string">&#x27;.png&#x27;</span>))   <span class="comment">#\mysqlinstall\mysql.tar.png</span></span><br><span class="line">p = Path(<span class="string">&#x27;README&#x27;</span>)  <span class="comment">#  README</span></span><br><span class="line"><span class="built_in">print</span>(p.with_suffix(<span class="string">&#x27;.txt&#x27;</span>))   <span class="comment">#  README.txt</span></span><br></pre></td></tr></table></figure>

<h6 id="判断方法"><a href="#判断方法" class="headerlink" title="判断方法"></a>判断方法</h6><p><code>is_dir()</code> 是否是目录，目录存在返回True </p>
<p><code>is_file()</code> 是否是普通文件，文件存在返回True </p>
<p><code>is_symlink()</code> 是否是软链接 </p>
<p><code>is_socket() </code>是否是socket文件 </p>
<p><code>is_block_device() </code>是否是块设备 </p>
<p><code>is_char_device()</code> 是否是字符设备 </p>
<p><code>is_absolute() </code>是否是绝对路径</p>
<p><code>resolve() </code>返回一个新的路径，这个新路径就是当前Path对象的绝对路径，如果是软链接则直接被解析 </p>
<p><code>absolute()</code> 获取绝对路径</p>
<p><code>exists() </code>目录或文件是否存在 </p>
<p><code>rmdir() </code>删除空目录。没有提供判断目录为空的方法 </p>
<p><code>touch(mode=0o666, exist_ok=True)</code> 创建一个文件 </p>
<p><code>as_uri()</code> 将路径返回成URI，例如’file:///etc/passwd’</p>
<p><code>mkdir(mode=0o777, parents=False, exist_ok=False) </code></p>
<ul>
<li><p>parents，是否创建父目录，True等同于mkdir -p；False时，父目录不存在，则抛出FileNotFoundError </p>
</li>
<li><p>exist_ok参数，在3.5版本加入。False时，路径存在，抛出FileExistsError；True时，FileExistsError被忽略</p>
</li>
</ul>
<p><code>iterdir() </code>迭代当前目录</p>
<h6 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h6><p>match（pattern）</p>
<p>模式匹配，成功返回True。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Path(<span class="string">&#x27;a/b.py&#x27;</span>).match(<span class="string">&#x27;*.py&#x27;</span>) <span class="comment"># True</span></span><br><span class="line">Path(<span class="string">&#x27;/a/b/c.py&#x27;</span>).match(<span class="string">&#x27;b/*.py&#x27;</span>) <span class="comment"># True</span></span><br><span class="line">Path(<span class="string">&#x27;/a/b/c.py&#x27;</span>).match(<span class="string">&#x27;a/*.py&#x27;</span>) <span class="comment"># False</span></span><br><span class="line">Path(<span class="string">&#x27;/a/b/c.py&#x27;</span>).match(<span class="string">&#x27;a/*/*.py&#x27;</span>) <span class="comment"># True</span></span><br><span class="line">Path(<span class="string">&#x27;/a/b/c.py&#x27;</span>).match(<span class="string">&#x27;a/**/*.py&#x27;</span>) <span class="comment"># True</span></span><br><span class="line">Path(<span class="string">&#x27;/a/b/c.py&#x27;</span>).match(<span class="string">&#x27;**/*.py&#x27;</span>) <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<p>stat()  相当于stat命令  ，lstat() 同stat()，但如果是符号链接，则显示符号链接本身的文件信息</p>
<h6 id="pathlib模块下的文件操作"><a href="#pathlib模块下的文件操作" class="headerlink" title="pathlib模块下的文件操作"></a>pathlib模块下的文件操作</h6><p><code>Path.open(mode=&#39;r&#39;, buffering=-1, encoding=None, errors=None, newline=None)</code></p>
<p>使用的方法类似内建函数open，返回一个文件对象。</p>
<p>3.5增加的新函数 </p>
<p><code>Path.read_bytes()  </code></p>
<p>以’rb’读取路径对应文件，并返回二进制流。看源码</p>
<p><code>Path.read_text(encoding=None, errors=None) </code></p>
<p>以’rt’方式读取路径对应文件，返回文本。</p>
<p><code>Path.write_bytes(data)  </code></p>
<p>以’wb’方式写入数据到路径对应文件。</p>
<p><code>Path.write_text(data, encoding=None, errors=None) </code></p>
<p>以’wt’方式写入字符串到路径对应文件。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">p = Path(<span class="string">&#x27;my_binary_file&#x27;</span>)</span><br><span class="line">p.write_bytes(<span class="string">b&#x27;Binary file contents&#x27;</span>)</span><br><span class="line">p.read_bytes() <span class="comment"># b&#x27;Binary file contents&#x27;</span></span><br><span class="line"> </span><br><span class="line">p = Path(<span class="string">&#x27;my_text_file&#x27;</span>)</span><br><span class="line">p.write_text(<span class="string">&#x27;Text file contents&#x27;</span>)</span><br><span class="line">p.read_text() <span class="comment"># &#x27;Text file contents&#x27;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line">p = Path(<span class="string">&#x27;o:/test.py&#x27;</span>)</span><br><span class="line">p.write_text(<span class="string">&#x27;hello python&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(p.read_text())</span><br><span class="line"><span class="keyword">with</span> p.<span class="built_in">open</span>() <span class="keyword">as</span> f:</span><br><span class="line">    <span class="built_in">print</span>(f.read(<span class="number">5</span>))</span><br></pre></td></tr></table></figure>

<h4 id="csv文件"><a href="#csv文件" class="headerlink" title="csv文件"></a>csv文件</h4><p>逗号分隔值Comma-Separated Values。 </p>
<p>CSV 是一个被行分隔符、列分隔符划分成行和列的文本文件。 </p>
<p>CSV 不指定字符编码。</p>
<p>行分隔符为\r\n，最后一行可以没有换行符 </p>
<p>列分隔符常为逗号或者制表符。 </p>
<p>每一行称为一条记录record </p>
<p>字段可以使用双引号括起来，也可以不使用。如果字段中出现了双引号、逗号、换行符必须使用双引号括起来。如果字段的值是双引号，使用两个双引号表示一个转义。</p>
<p>表头可选，和字段列对齐就行了。</p>
<p>手动生成csv文件</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"></span><br><span class="line">p = Path(<span class="string">&#x27;D:/tmp/test.csv&#x27;</span>)</span><br><span class="line">parent = p.parent</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> parent.exists():</span><br><span class="line">    parent.mkdir(parents=<span class="literal">True</span>,exist_ok =<span class="literal">True</span>) <span class="comment">#exist_ok 用在python3.5之后，如果文件目录存在，True则压制异常。</span></span><br><span class="line">csv_body = <span class="string">&#x27;&#x27;&#x27;\</span></span><br><span class="line"><span class="string">id,name,age,comment</span></span><br><span class="line"><span class="string">1,zs,18,&quot;I&#x27;m 18&quot;</span></span><br><span class="line"><span class="string">2,ls,20,&quot;this is a &quot;&quot;test&quot;&quot; string.&quot;</span></span><br><span class="line"><span class="string">3,ww,23,&quot;你好</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">计算机</span></span><br><span class="line"><span class="string">&quot;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">p.write_text(csv_body)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="csv模块"><a href="#csv模块" class="headerlink" title="csv模块"></a>csv模块</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reader</span>(<span class="params">iterable, dialect=<span class="string">&#x27;excel&#x27;</span>, *args, **kwargs</span>)</span></span><br></pre></td></tr></table></figure>

<p>返回一个reader对象，是一个行迭代器</p>
<p>默认使用excel方言，如下：</p>
<ul>
<li><p>delimiter 列分隔符,逗号</p>
</li>
<li><p>lineterminator 行分隔符\r\n</p>
</li>
<li><p>quotechar 字段的引用符号，缺省为”双引号</p>
</li>
<li><p>双引号的处理</p>
<ul>
<li>doublequote 双引号的处理，默认为True。如果碰到数据中有双引号，而quotechar也是双引号，True则使用2个双引号表示，False表示使用转义字符将作为双引号的前缀。</li>
<li>escapechar 一个转义字符，默认为None</li>
<li>writer = csv.writer(f, doublequote=False, escapechar=‘@’) 遇到双引号，则必须提供转义字符</li>
</ul>
</li>
<li><p>quoting 指定双引号的规则</p>
<ul>
<li><p>QUOTE_ALL 所有字段</p>
</li>
<li><p>QUOTE_MINIMAL特殊字符字段，Excel方言使用该规则</p>
</li>
<li><p>QUOTE_NONNUMERIC非数字字段</p>
</li>
<li><p>QUOTE_NONE都不使用引号。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">writer</span>(<span class="params">fileobj, dialect=<span class="string">&#x27;excel&#x27;</span>, *args, **kwargs</span>)</span></span><br></pre></td></tr></table></figure>

<p>返回DictWriter实例，主要的方法有writerow，writerows。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"> </span><br><span class="line">p = Path(<span class="string">&#x27;d://tmp/tesr.csv&#x27;</span>)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="built_in">str</span>(p)) <span class="keyword">as</span> f:</span><br><span class="line">    reader = csv.reader(f)    <span class="comment">#返回一个迭代对象</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">next</span>(reader))     <span class="comment">#不回头</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">next</span>(reader))     </span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> reader:</span><br><span class="line">        <span class="built_in">print</span>(line)</span><br><span class="line"> </span><br><span class="line">rows = [</span><br><span class="line">    [<span class="number">4</span>,<span class="string">&#x27;tom&#x27;</span>,<span class="number">22</span>,<span class="string">&#x27;tom&#x27;</span>],</span><br><span class="line">    (<span class="number">5</span>,<span class="string">&#x27;jerry&#x27;</span>,<span class="number">24</span>,<span class="string">&#x27;jerry&#x27;</span>),</span><br><span class="line">    (<span class="number">6</span>,<span class="string">&#x27;justin&#x27;</span>,<span class="number">22</span>,<span class="string">&#x27;just\t&quot;in&#x27;</span>),</span><br><span class="line">    <span class="string">&quot;abcdefghi&quot;</span>,</span><br><span class="line">    ((<span class="number">1</span>,),(<span class="number">2</span>,))</span><br><span class="line">]</span><br><span class="line">row = rows[<span class="number">0</span>]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="built_in">str</span>(p), <span class="string">&#x27;a&#x27;</span>,newline=<span class="string">&quot;&quot;</span>) <span class="keyword">as</span> f:  <span class="comment">#newline为了不换行</span></span><br><span class="line">    writer = csv.writer(f)</span><br><span class="line">    writer.writerow(row)   <span class="comment">#一次写一条</span></span><br><span class="line">    writer.writerows(rows)    <span class="comment">#将所有的一次写入</span></span><br></pre></td></tr></table></figure>

<h4 id="ini文件"><a href="#ini文件" class="headerlink" title="ini文件"></a>ini文件</h4><p>一般作为配置文件。</p>
<p>ini文件：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[DEFAULT]</span></span><br><span class="line"><span class="attr">a</span> = test</span><br><span class="line"> </span><br><span class="line"><span class="section">[mysql]</span></span><br><span class="line"><span class="attr">default-character-set</span>=utf8</span><br><span class="line"> </span><br><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">datadir</span> =/dbserver/data</span><br><span class="line"><span class="attr">port</span> = <span class="number">33060</span></span><br><span class="line"><span class="attr">character-set-server</span>=utf8</span><br><span class="line"><span class="attr">sql_mode</span>=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES</span><br></pre></td></tr></table></figure>

<p>中括号里面的部分称为section，译作节、区、段。 </p>
<p>每一个section内，都是key=value形成的键值对，key称为option选项。</p>
<p>这里的DEFAULT是缺省section的名字，必须大写。</p>
<h5 id="configparser模块"><a href="#configparser模块" class="headerlink" title="configparser模块"></a>configparser模块</h5><p>configparser模块的ConfigParser类就是用来操作。</p>
<p>可以将section当做key，section存储着键值对组成的字典，可以把ini配置文件当做一个嵌套的字典。默认使用的是有序字典。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">read(filenames, encoding=<span class="literal">None</span>) </span><br><span class="line"><span class="comment">#读取ini文件，可以是单个文件，也可以是文件列表。可以指定文件编码。</span></span><br><span class="line">sections()  <span class="comment">#返回section列表。缺省section不包括在内。 </span></span><br><span class="line">add_section(section_name)   <span class="comment">#增加一个section。 </span></span><br><span class="line"></span><br><span class="line">has_section(section_name)   <span class="comment">#判断section是否存在 </span></span><br><span class="line">options(section)   <span class="comment">#返回section的所有option，会追加缺省section的option </span></span><br><span class="line"></span><br><span class="line">has_option(section, option)  <span class="comment">#判断section是否存在这个option</span></span><br><span class="line">get(section, option, *, raw=<span class="literal">False</span>, <span class="built_in">vars</span>=<span class="literal">None</span>[, fallback]) </span><br><span class="line"></span><br><span class="line"><span class="comment">#从指定的段的选项上取值，如果找到返回，如果没有找到就去找DEFAULT段有没有。</span></span><br><span class="line"></span><br><span class="line">getint(section, option, *, raw=<span class="literal">False</span>, <span class="built_in">vars</span>=<span class="literal">None</span>[, fallback]) </span><br><span class="line">getfloat(section, option, *, raw=<span class="literal">False</span>, <span class="built_in">vars</span>=<span class="literal">None</span>[, fallback]) </span><br><span class="line">getboolean(section, option, *, raw=<span class="literal">False</span>, <span class="built_in">vars</span>=<span class="literal">None</span>[, fallback]) </span><br><span class="line"><span class="comment">#上面3个方法和get一样，返回指定类型数据。</span></span><br><span class="line"></span><br><span class="line">items(raw=<span class="literal">False</span>, <span class="built_in">vars</span>=<span class="literal">None</span>) </span><br><span class="line">items(section, raw=<span class="literal">False</span>, <span class="built_in">vars</span>=<span class="literal">None</span>) </span><br><span class="line"><span class="comment">#没有section，则返回所有section名字及其对象；如果指定section，则返回这个指定的section的键值对组成二元组。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>(section, option, value) </span><br><span class="line"><span class="comment">#section存在的情况下，写入option=value，要求option、value必须是字符串。</span></span><br><span class="line"></span><br><span class="line">remove_section(section) </span><br><span class="line"><span class="comment">#移除section及其所有option </span></span><br><span class="line"></span><br><span class="line">remove_option(section, option) </span><br><span class="line"><span class="comment">#移除section下的option。</span></span><br><span class="line"></span><br><span class="line">write(fileobject, space_around_delimiters=<span class="literal">True</span>) </span><br><span class="line"><span class="comment">#将当前config的所有内容写入fileobject中，一般open函数使用w模式。</span></span><br></pre></td></tr></table></figure>
<p>代码示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> configparser <span class="keyword">import</span> ConfigParser</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"></span><br><span class="line">filename = Path(<span class="string">&quot;d://tmp/mysql.ini&quot;</span>)</span><br><span class="line">newfilename = Path(<span class="string">&quot;d://tmp/mysql111.ini&quot;</span>)</span><br><span class="line"></span><br><span class="line">cfg = ConfigParser()</span><br><span class="line">read_ok = cfg.read(<span class="built_in">str</span>(filename))</span><br><span class="line"><span class="built_in">print</span>(read_ok)</span><br><span class="line"><span class="built_in">print</span>(cfg.sections())</span><br><span class="line"><span class="built_in">print</span>(cfg.has_section(<span class="string">&quot;mysql&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-&quot;</span>*<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> cfg.items():   <span class="comment">#未指定section</span></span><br><span class="line">    <span class="built_in">print</span>(k,<span class="built_in">type</span>(k))</span><br><span class="line">    <span class="built_in">print</span>(v,<span class="built_in">type</span>(v))</span><br><span class="line">    <span class="built_in">print</span>(cfg.items(k))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;~~~~~~~~~~~~~~~~~~&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-&quot;</span>*<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> cfg.items(<span class="string">&quot;mysqld&quot;</span>):  <span class="comment">#指定section</span></span><br><span class="line">    <span class="built_in">print</span>(k,<span class="built_in">type</span>(k))</span><br><span class="line">    <span class="built_in">print</span>(v,<span class="built_in">type</span>(v))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;~~~~~~~~~~&quot;</span>)</span><br><span class="line"></span><br><span class="line">tmp = cfg.get(<span class="string">&quot;mysqld&quot;</span>,<span class="string">&quot;port&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(tmp, <span class="built_in">type</span>(tmp))</span><br><span class="line"><span class="built_in">print</span>(cfg.get(<span class="string">&quot;mysqld&quot;</span>, <span class="string">&quot;a&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(cfg.get(<span class="string">&quot;mysqld&quot;</span>, <span class="string">&quot;python&quot;</span> , fallback= <span class="string">&quot;linux&quot;</span>))  <span class="comment">#按照类型，fallbac：给与缺省值</span></span><br><span class="line"></span><br><span class="line">tmp = cfg.getint(<span class="string">&quot;mysqld&quot;</span>, <span class="string">&quot;port&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(tmp), tmp)</span><br><span class="line"></span><br><span class="line">cfg.add_section(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">cfg.<span class="built_in">set</span>(<span class="string">&quot;test&quot;</span>,<span class="string">&quot;test1&quot;</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line">cfg.<span class="built_in">set</span>(<span class="string">&quot;test&quot;</span>,<span class="string">&quot;test2&quot;</span>,<span class="string">&quot;2&quot;</span>)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(newfilename,<span class="string">&quot;w+&quot;</span>,newline=<span class="string">&quot;&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    cfg.write(f)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(cfg.getint(<span class="string">&quot;test&quot;</span> , <span class="string">&quot;test1&quot;</span>))</span><br><span class="line"></span><br><span class="line">cfg.remove_option(<span class="string">&quot;test&quot;</span>, <span class="string">&quot;test1&quot;</span>)</span><br><span class="line"><span class="comment"># cfg.remove_section(&quot;test&quot;)</span></span><br><span class="line"><span class="comment"># print(&quot;x&quot; in cfg[&quot;test2&quot;])</span></span><br><span class="line"><span class="comment">#字典操作</span></span><br><span class="line">cfg[<span class="string">&quot;test3&quot;</span>] = &#123;<span class="string">&quot;c&quot;</span>:<span class="string">&quot;1000&quot;</span>&#125;   <span class="comment">#没有落地，在内存中修改</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x&quot;</span> <span class="keyword">in</span> cfg[<span class="string">&quot;test&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c&quot;</span> <span class="keyword">in</span> cfg[<span class="string">&quot;test3&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 其他内部方式</span></span><br><span class="line"><span class="built_in">print</span>(cfg._<span class="built_in">dict</span>)  <span class="comment"># 返回默认的字典类型，默认使用有序字典</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> cfg._sections.items():</span><br><span class="line">    <span class="built_in">print</span>(k, v)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> cfg._sections[<span class="string">&#x27;mysqld&#x27;</span>].items():</span><br><span class="line">    <span class="built_in">print</span>(k,v)</span><br><span class="line"><span class="comment">#重新写入文件</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(newfilename, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    cfg.write(f)</span><br></pre></td></tr></table></figure>



<h4 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h4><pre><code>要设计一套协议，按照某种规则，把内存中数据保存到文件中，文件是一个字节序列，所以必须把数据转换成&lt;font color=red &gt;字节&lt;/font&gt;序列，输出到文件。这就是序列化。反之，从文件的字节序列恢复到内存。就是反序列化。
</code></pre>
<ol>
<li><p>serialization：序列化<br>将内存中对象存储下来，变成一个个字节 –&gt;  二进制</p>
</li>
<li><p>deseiralization：反序列化<br>将文件中的一个个字节恢复成内存中对象   &lt;–二进制</p>
</li>
</ol>
<p>序列化保存到文件就是持久化，可以将数据序列化后持久化，或者网络传输；也可以将文件中或者网络中接收到的字节序列反序列化。</p>
<h5 id="pickle库"><a href="#pickle库" class="headerlink" title="pickle库"></a>pickle库</h5><p>python中的序列化，反序列化模块。</p>
<p>dumps  对象序列化为bytes对象      dump   对象序列化到文件对象，就是存入文件</p>
<p>loads 从bytes对象反序列化     load  对象反序列化，从文件读取数据</p>
<h5 id="序列化的应用"><a href="#序列化的应用" class="headerlink" title="序列化的应用"></a>序列化的应用</h5><p>一般来说，本地序列化的情况，应用较少。大多数场景都应用在网络传输中。 </p>
<p>将数据序列化后通过网络传输到远程节点，远程服务器上的服务将接收到的数据反序列化后，就可以使用了。 </p>
<p>但是，要注意一点，远程接收端，反序列化时必须有对应的数据类型，否则就会报错。尤其是自定义类，必须远程的有一致的定义。</p>
<p>现在，大多数项目，都不是单机的，也不是单服务的。需要通过网络将数据传送到其他节点上去，这就需要大量的序列化、反序列化过程。</p>
<p>但是，问题是，Python程序之间还可以都是用pickle解决序列化、反序列化，如果是跨平台、跨语言、跨协议pickle就不太适合了，就需要公共的协议。例如XML、Json、Protocol Buffer等。</p>
<p>不同的协议，效率不同、学习曲线不同，适用不同场景，要根据不同的情况分析选型。</p>
<h5 id="Json"><a href="#Json" class="headerlink" title="Json"></a>Json</h5><pre><code>Json(JavaScript Object Notation，JS对象标记)是一种轻量级的数据交换格式。它基于 ECMAScript (w3c组织制定的JS规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。网址: http://json.org/
</code></pre>
<p>Json的数据类型</p>
<p>值：双引号引起来的字符串，数值，true和false，null，对象，数组，这些都是值 </p>
<p>字符串：有正负，有整数，浮点数。</p>
<p>对象：无序的键值对的集合，格式{key:value…}，key必须是一个字符串，需要双引号包围这个字符串，value可以是任意合法的值。</p>
<p>数组：有序的值的集合  格式[val1，，，，valn]</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;person&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;tom&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;age&quot;</span>: <span class="number">18</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;jerry&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;age&quot;</span>: <span class="number">16</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;total&quot;</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Json模块</p>
<p>Python支持少量内建数据类型到Json类型的转换</p>
<table>
<thead>
<tr>
<th>Python类型</th>
<th>Json类型</th>
</tr>
</thead>
<tbody><tr>
<td>True</td>
<td>true</td>
</tr>
<tr>
<td>False</td>
<td>false</td>
</tr>
<tr>
<td>None</td>
<td>null</td>
</tr>
<tr>
<td>str</td>
<td>string</td>
</tr>
<tr>
<td>int</td>
<td>integer</td>
</tr>
<tr>
<td>float</td>
<td>float</td>
</tr>
<tr>
<td>list</td>
<td>array</td>
</tr>
<tr>
<td>dict</td>
<td>object</td>
</tr>
</tbody></table>
<p>常用方法</p>
<table>
<thead>
<tr>
<th>Python类型</th>
<th>Json类型</th>
</tr>
</thead>
<tbody><tr>
<td>dumps</td>
<td>Json编码</td>
</tr>
<tr>
<td>dump</td>
<td>Json编码并存入文件</td>
</tr>
<tr>
<td>loads</td>
<td>Json解码</td>
</tr>
<tr>
<td>load</td>
<td>Json解码，从文件读取数据</td>
</tr>
</tbody></table>
<p>一般Json编码的数据很少落地，数据都是通过网络传输，传输的时候，要考虑压缩它，节省流量。本质来说它就是个文本，就是个字符串。</p>
<h5 id="MessagePack"><a href="#MessagePack" class="headerlink" title="MessagePack"></a>MessagePack</h5><p>MessagePack是一个基于二进制高效的对象序列化类库，可用于跨语言通信。 </p>
<p>它可以像JSON那样，在许多种语言之间交换结构对象。 </p>
<p>兼容 json和pickle。</p>
<p>MessagePack简单易用，高效压缩，支持语言丰富。 </p>
<p>所以，用它序列化也是一种很好的选择。</p>
<p>安装：$pip install msgpack-python</p>
<p>常用方法：</p>
<p>packb 序列化对象。提供了dumps来兼容pickle和json。 </p>
<p>unpackb 反序列化对象。提供了loads来兼容。</p>
<p>pack 序列化对象保存到文件对象。提供了dump来兼容。</p>
<p>unpack 反序列化对象保存到文件对象。提供了load来兼容。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> msgpack</span><br><span class="line"></span><br><span class="line">d = &#123;<span class="string">&quot;person&quot;</span>:[&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;tom&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">18</span>&#125;,&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;jerry&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">16</span>&#125;],<span class="string">&quot;total&quot;</span>:<span class="number">2</span>&#125;</span><br><span class="line">j = json.dumps(d)</span><br><span class="line"><span class="built_in">print</span>(j, <span class="built_in">type</span>(j), <span class="built_in">len</span>(j)) <span class="comment"># 请注意引号的变化</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(j.replace(<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;&#x27;</span>))) <span class="comment"># 72 bytes 注意这样替换的压缩是不对的</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-&quot;</span>*<span class="number">30</span>)</span><br><span class="line">p = pickle.dumps(d)</span><br><span class="line"><span class="built_in">print</span>(p)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(p))  <span class="comment"># 101 bytes</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-&quot;</span>*<span class="number">30</span>)</span><br><span class="line">m = msgpack.dumps(d)</span><br><span class="line"><span class="built_in">print</span>(m)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(m)) <span class="comment"># 48 bytes</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-&quot;</span>*<span class="number">30</span>)</span><br><span class="line">u = msgpack.unpackb(m)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(u), u)</span><br><span class="line">u = msgpack.loads(m, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(u), u)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;person&quot;: [&#123;&quot;name&quot;: &quot;tom&quot;, &quot;age&quot;: 18&#125;, &#123;&quot;name&quot;: &quot;jerry&quot;, &quot;age&quot;: 16&#125;], &quot;total&quot;: 2&#125; &lt;class &#x27;str&#x27;&gt; 82</span><br><span class="line">72</span><br><span class="line">------------------------------</span><br><span class="line">b&#x27;\x80\x03&#125;q\x00(X\x06\x00\x00\x00personq\x01]q\x02(&#125;q\x03(X\x04\x00\x00\x00nameq\x04X\x03\x00\x00\x00tomq\x05X\x03\x00\x00\x00ageq\x06K\x12u&#125;q\x07(h\x04X\x05\x00\x00\x00jerryq\x08h\x06K\x10ueX\x05\x00\x00\x00totalq\tK\x02u.&#x27;</span><br><span class="line">101</span><br><span class="line">------------------------------</span><br><span class="line">b&#x27;\x82\xa6person\x92\x82\xa4name\xa3tom\xa3age\x12\x82\xa4name\xa5jerry\xa3age\x10\xa5total\x02&#x27;</span><br><span class="line">48</span><br><span class="line">------------------------------</span><br><span class="line">&lt;class &#x27;dict&#x27;&gt; &#123;b&#x27;person&#x27;: [&#123;b&#x27;name&#x27;: b&#x27;tom&#x27;, b&#x27;age&#x27;: 18&#125;, &#123;b&#x27;name&#x27;: b&#x27;jerry&#x27;, b&#x27;age&#x27;: 16&#125;], b&#x27;total&#x27;: 2&#125;</span><br><span class="line">&lt;class &#x27;dict&#x27;&gt; &#123;&#x27;person&#x27;: [&#123;&#x27;name&#x27;: &#x27;tom&#x27;, &#x27;age&#x27;: 18&#125;, &#123;&#x27;name&#x27;: &#x27;jerry&#x27;, &#x27;age&#x27;: 16&#125;], &#x27;total&#x27;: 2&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://vampireqian.github.io/2017/09/10/09python%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E3%80%81%E8%B7%AF%E5%BE%84%E5%A4%84%E7%90%86%E3%80%81%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" data-id="ckxlw2jbf000h0zex4y6v5ju2" data-title="python-文件处理、路径处理、序列化和反序列化" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/" rel="tag">python</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-10python文件处理、路径处理、序列化和反序列化" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2017/09/10/10python%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E3%80%81%E8%B7%AF%E5%BE%84%E5%A4%84%E7%90%86%E3%80%81%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" class="article-date">
  <time class="dt-published" datetime="2017-09-09T16:00:00.000Z" itemprop="datePublished">2017-09-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/python/">python</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2017/09/10/10python%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E3%80%81%E8%B7%AF%E5%BE%84%E5%A4%84%E7%90%86%E3%80%81%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/">python-文件处理、路径处理、序列化和反序列化</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="文件IO常用操作"><a href="#文件IO常用操作" class="headerlink" title="文件IO常用操作"></a>文件IO常用操作</h4><p>一般说IO操作，指的是文件IO。</p>
<p>把文件存储到磁盘上的这个过程，叫做落地。</p>
<table>
<thead>
<tr>
<th align="center">column</th>
<th align="center">column</th>
</tr>
</thead>
<tbody><tr>
<td align="center">open</td>
<td align="center">打开</td>
</tr>
<tr>
<td align="center">read</td>
<td align="center">读取</td>
</tr>
<tr>
<td align="center">write</td>
<td align="center">写入</td>
</tr>
<tr>
<td align="center">close</td>
<td align="center">关闭</td>
</tr>
<tr>
<td align="center">readline</td>
<td align="center">行读取</td>
</tr>
<tr>
<td align="center">readlines</td>
<td align="center">多行读取</td>
</tr>
<tr>
<td align="center">seek</td>
<td align="center">文件指针操作</td>
</tr>
<tr>
<td align="center">tell</td>
<td align="center">指针位置</td>
</tr>
</tbody></table>
<h5 id="open打开操作"><a href="#open打开操作" class="headerlink" title="open打开操作"></a>open打开操作</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">open</span>(file, mode=<span class="string">&#x27;r&#x27;</span>, buffering=-<span class="number">1</span>, encoding=<span class="literal">None</span>, errors=<span class="literal">None</span>, newline=<span class="literal">None</span>, closefd=<span class="literal">True</span>,opener=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;file名字&quot;</span>)   <span class="comment">#文件对象</span></span><br><span class="line"><span class="built_in">print</span>(f.read())		<span class="comment">#读取文件</span></span><br><span class="line">f.close()		<span class="comment">#关闭文件</span></span><br></pre></td></tr></table></figure>

<p>打开一个文件，返回一个文件对象(流对象)和文件描述符。打开文件失败，则返回异常。<br>基本使用： 创建一个文件test，然后打开它，用完关闭。</p>
<p>文件操作中最常用的就是读和写。文件访问的模式有两种：文本模式和二进制模式。</p>
<blockquote>
<p>注：windows中使用codepage代码页。可以认为每一个代码页就是一张编码表 cp936和gbk等价。</p>
</blockquote>
<h5 id="mode模式"><a href="#mode模式" class="headerlink" title="mode模式"></a>mode模式</h5><table>
<thead>
<tr>
<th>描述字符</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>缺省的，表示只读打开</td>
</tr>
<tr>
<td>w</td>
<td>只写打开，有的话就清除重新写</td>
</tr>
<tr>
<td>x</td>
<td>创建并写入一个新文件</td>
</tr>
<tr>
<td>a</td>
<td>写入打开，如果文件存在，则追加</td>
</tr>
<tr>
<td>b</td>
<td>二进制模式</td>
</tr>
<tr>
<td>t</td>
<td>缺省的，文本模式</td>
</tr>
<tr>
<td>+</td>
<td>读写打开一个文件，给原来只读、只写的增加缺失的功能</td>
</tr>
</tbody></table>
<p>open默认是只读模式r打开已经存在的文件。</p>
<ul>
<li><p>r 只读打开文件，如果使用write方法，会抛异常。 如果文件不存在，抛出FileNotFoundError异常。</p>
</li>
<li><p>w 表示只写方式打开，如果读取则抛出异常 如果文件不存在，则直接创建文件 如果文件存在，则清空文件内容。</p>
</li>
<li><p>x 文件不存在，创建文件，并只写方式打开，文件存在，抛出FileExistsError异常。</p>
</li>
<li><p>a 文件存在，只写打开，追加内容 文件不存在，则创建后，只写打开，追加内容</p>
</li>
<li><p>r是只读，wxa都是只写。 wxa都可以产生新文件，w不管文件存在与否，都会生成全新内容的文件；a不管文件是否存在，都能在打开的文件尾部追加；x必须要求文件事先不存在，自己造一个新文件。</p>
</li>
<li><p>+为r、w、a、x提供缺失的读或写功能，但是，获取文件对象依旧按照r、w、a、x自己的特征。 +不能单独使用，可以认为它是为前面的模式字符做增强功能的。</p>
</li>
</ul>
<p>t和b：</p>
<ul>
<li><p>文本模式t 字符流，将文件的字节按照某种字符编码理解，按照字符操作。open的默认mode就是rt。</p>
</li>
<li><p>二进制模式b 字节流，将文件就按照字节理解，与字符编码无关。二进制模式操作时，字节操作使用bytes类型。</p>
</li>
</ul>
<p>t/b不能单独存在，要和a/w/x/r配合使用。</p>
<h5 id="seek文件指针"><a href="#seek文件指针" class="headerlink" title="seek文件指针"></a>seek文件指针</h5><p>文件指针，指向当前字节位置。</p>
<p>mode = r，指针起始在0  ，mode  =  a  指针起始在EOF。</p>
<p>tell（）：显示指针当前位置。</p>
<p>seek(offset[, whence]) 移动文件指针位置。offest偏移多少字节，whence从哪里开始。</p>
<ul>
<li><p>文本模式下 whence 0 缺省值，表示从头开始，offset只能正整数 whence 1 表示从当前位置，offset只接受0，whence 2 表示从EOF开始，offest只接受0</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文本模式</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;test4&#x27;</span>,<span class="string">&#x27;r+&#x27;</span>)</span><br><span class="line">f.tell() <span class="comment"># 起始</span></span><br><span class="line">f.read()</span><br><span class="line">f.tell() <span class="comment"># EOF</span></span><br><span class="line">f.seek(<span class="number">0</span>) <span class="comment"># 起始</span></span><br><span class="line">f.read()</span><br><span class="line">f.seek(<span class="number">2</span>,<span class="number">0</span>)</span><br><span class="line">f.read()</span><br><span class="line">f.seek(<span class="number">2</span>,<span class="number">0</span>)</span><br><span class="line">f.seek(<span class="number">2</span>,<span class="number">1</span>) <span class="comment"># offset必须为0</span></span><br><span class="line">f.seek(<span class="number">2</span>,<span class="number">2</span>) <span class="comment"># offset必须为0</span></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure></li>
<li><p>二进制模式下 whence 0 缺省值，表示从头开始，offest只能正整数 whence 1表示从当前位置，offest可正可负，whence 2 表示从EOF开始，offest可正可负。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 二进制模式</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;test4&#x27;</span>,<span class="string">&#x27;rb+&#x27;</span>)</span><br><span class="line">f.tell() <span class="comment"># 起始</span></span><br><span class="line">f.read()</span><br><span class="line">f.tell() <span class="comment"># EOF</span></span><br><span class="line">f.write(<span class="string">b&#x27;abc&#x27;</span>)</span><br><span class="line">f.seek(<span class="number">0</span>) <span class="comment"># 起始</span></span><br><span class="line">f.seek(<span class="number">2</span>,<span class="number">1</span>) <span class="comment"># 从当前指针开始，向后2</span></span><br><span class="line">f.read()</span><br><span class="line"> </span><br><span class="line">f.seek(-<span class="number">2</span>,<span class="number">2</span>) <span class="comment"># 从EOF开始，向前2</span></span><br><span class="line">f.read()</span><br><span class="line">f.seek(-<span class="number">20</span>,<span class="number">2</span>) <span class="comment"># OSError</span></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure></li>
<li><p>二进制模式支持任意起点的偏移，从头、从尾、从中间位置开始。 向后seek可以超界，但是向前seek的时候，不能超界，否则抛异常。</p>
</li>
</ul>
<h5 id="buffering缓冲区"><a href="#buffering缓冲区" class="headerlink" title="buffering缓冲区"></a>buffering缓冲区</h5><p>-1 表示使用缺省大小的buffer。如果是二进制模式，使io.DEFAULT_BUFFER_SIZE值，默认是<font color= red>4096或者8192</font>。如果是文本模式，如果是终端设备，是行缓存方式，如果不是，则使用二进制模式的策略。</p>
<ul>
<li>0 只在二进制模式使用，表示关buffer</li>
<li>1 只在文本模式使用，表示使用行缓冲。意思就是见到换行符就flush</li>
<li>大于1 用于指定buffer的大小</li>
</ul>
<p>buffer 缓冲区 </p>
<p>缓冲区一个内存空间，一般来说是一个FIFO队列，到缓冲区满了或者达到阈值，数据才会flush到磁盘。</p>
<p>flush() 将缓冲区数据写入磁盘 close() 关闭前会调用flush()。</p>
<p>io.DEFAULT_BUFFER_SIZE 缺省缓冲区大小，字节。</p>
<table>
<thead>
<tr>
<th>buffering</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>buffering = -1</td>
<td>t和b，都是io.DEFAULT_BUFFER_SIZE</td>
</tr>
<tr>
<td>buffering = 0</td>
<td>b 关闭缓冲区 <br/>t 不支持</td>
</tr>
<tr>
<td>buffering = 1</td>
<td>b 就一个字节<br/>t 行缓冲，遇到换行符才flush</td>
</tr>
<tr>
<td>buffering &gt; 1</td>
<td>b模式表示行缓冲大小。缓冲区的值可以超过io.DEFAULT_BUFFER_SIZE，直到设定的值超出后才把缓冲区flush 。</td>
</tr>
<tr>
<td>t模式，是io.DEFAULT_BUFFER_SIZE字节，flush完后把当前字符串也写入磁盘</td>
<td></td>
</tr>
</tbody></table>
<p>一般来说：</p>
<ol>
<li>文本模式，一般都用默认缓冲区大小</li>
<li>二进制模式，是一个个字节的操作，可以指定buffer的大小</li>
<li>一般来说，默认缓冲区大小是个比较好的选择，除非明确知道，否则不调整它</li>
<li>一般编程中，明确知道需要写磁盘了，都会手动调用一次flush，而不是等到自动flush或者close的时候</li>
</ol>
<h5 id="其他参数"><a href="#其他参数" class="headerlink" title="其他参数"></a>其他参数</h5><p>编码：windows下缺省GBK（0xB0A1），Linux下缺省UTF-8（0xE5 95 8A）</p>
<p>errors ：编码错误将被捕获 None和strict表示有编码错误将抛出ValueError异常；ignore表示忽略</p>
<p>newline：文本模式中，换行的转换。可以为None、’’ 空串、’\r’、’\n’、’\r\n’ 。</p>
<ul>
<li>None表示’\r’、’\n’、’\r\n’都被转换为’\n’；</li>
<li>‘’  表示不会自动转换通用换行符；其它合法字符表示换行符就是指定字符，就会按照指定字符分行写。</li>
<li>‘\n’或’’表示’\n’不替换；其它合法字符表示’\n’会被替换为指定的字符</li>
</ul>
<p>closefd：关闭文件描述符，True表示关闭它。False会在文件关闭后保持这个描述符。fileobj.fileno()查看。</p>
<p><strong>文件描述符</strong>：Linux一切皆文件，文件打开后都会有一个位于的文件描述符，在计算机系统中是一个有限的资源。0,1,2,标准输入，标准输出，标准错误输出。</p>
<p>对于类似于文件对象的IO对象，一般来说都需要在不使用的时候关闭、注销，以释放资源。<br>IO被打开的时候，会获得一个文件描述符。计算机资源是有限的，所以操作系统都会做限制。就是为了保护计算机的资源不要被完全耗尽，计算资源是共享的，不是独占的。 </p>
<p>一般情况下，除非特别明确的知道资源情况，否则不要提高资源的限制值来解决问题。</p>
<h5 id="read（）"><a href="#read（）" class="headerlink" title="read（）"></a>read（）</h5><p>read(size=-1)<br>size表示读取的多少个字符或字节；负数或者None表示读取到EOF</p>
<p>readline(size=-1)<br>一行行读取文件内容。size设置一次能读取行内几个字符或字节。</p>
<p>readlines(hint=-1)<br>读取所有行的列表。指定hint则返回指定的行数。</p>
<h5 id="write（）"><a href="#write（）" class="headerlink" title="write（）"></a>write（）</h5><p>write(s)，把字符串s写入到文件中并返回字符的个数 writelines(lines)，将字符串列表写入文件。</p>
<h5 id="close（）"><a href="#close（）" class="headerlink" title="close（）"></a>close（）</h5><p>flush并关闭文件对象。<br>文件已经关闭，再次关闭没有任何效果。</p>
<h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>seekable（）</td>
<td>是否可seek</td>
</tr>
<tr>
<td>readable（）</td>
<td>是否可读</td>
</tr>
<tr>
<td>writeable（）</td>
<td>是否可写</td>
</tr>
<tr>
<td>closed（）</td>
<td>是否已经关闭</td>
</tr>
</tbody></table>
<h5 id="上下文管理"><a href="#上下文管理" class="headerlink" title="上下文管理"></a>上下文管理</h5><p>1、异常处理<br>当出现异常的时候，拦截异常。但是，因为很多代码都可能出现OSError异常，还不好判断异常就是应为资源限制产生的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f.write(<span class="string">&quot;abc&quot;</span>) <span class="comment"># 文件只读，写入失败</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    f.close() <span class="comment"># 这样才行</span></span><br></pre></td></tr></table></figure>

<p>使用finally可以保证打开的文件可以被关闭。</p>
<p>上下文管理</p>
<ol>
<li><p>使用with … as 关键字</p>
</li>
<li><p>上下文管理的语句块并不会开启新的作用域</p>
</li>
<li><p>with语句块执行完的时候，会自动关闭文件对象</p>
</li>
</ol>
<h4 id="StringIO操作"><a href="#StringIO操作" class="headerlink" title="StringIO操作"></a>StringIO操作</h4><p>io模块中的类</p>
<pre><code>from io import StringIO
</code></pre>
<p>内存中，开辟的一个文本模式的buffer，可以像文件对象一样操作它</p>
<p>当close方法被调用的时候，这个buffer会被释放</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> StringIO</span><br><span class="line"><span class="comment"># 内存中构建</span></span><br><span class="line">sio = StringIO() <span class="comment"># 像文件对象一样操作</span></span><br><span class="line"><span class="built_in">print</span>(sio.readable(), sio.writable(), sio.seekable())<span class="comment"># True True True</span></span><br><span class="line">sio.write(<span class="string">&quot;luo\nPython&quot;</span>)</span><br><span class="line">sio.seek(<span class="number">0</span>)  </span><br><span class="line"><span class="built_in">print</span>(sio.readline())  <span class="comment">#magedu</span></span><br><span class="line"><span class="built_in">print</span>(sio.getvalue()) <span class="comment"># 无视指针，输出全部内容  magedu   Python</span></span><br><span class="line">sio.close()</span><br></pre></td></tr></table></figure>

<p>好处</p>
<pre><code>一般来说，磁盘的操作比内存的操作要慢得多，内存足够的情况下，一般的思路是少落地，减少磁盘IO的过程，可以大大的提高程序的运行效率。
</code></pre>
<h4 id="BytesIO操作"><a href="#BytesIO操作" class="headerlink" title="BytesIO操作"></a>BytesIO操作</h4><p>io模块中的类</p>
<pre><code>from io import BytesIO
</code></pre>
<p>内存中，开辟的一个二进制模式的buffer，可以像文件对象一样操作它</p>
<p>当close方法被调用的时候，这个buffer会被释放</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO <span class="comment"># 内存中构建</span></span><br><span class="line">bio = BytesIO()</span><br><span class="line"><span class="built_in">print</span>(bio.readable(), bio.writable(), bio.seekable()) <span class="comment">#True True True</span></span><br><span class="line">bio.write(<span class="string">b&quot;luo\nPython&quot;</span>)</span><br><span class="line">bio.seek(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(bio.readline())  <span class="comment"># b&#x27;magedu\n&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(bio.getvalue()) <span class="comment"># 无视指针，输出全部内容   b&#x27;magedu\nPython&#x27;</span></span><br><span class="line">bio.close()</span><br></pre></td></tr></table></figure>

<h4 id="file-like对象"><a href="#file-like对象" class="headerlink" title="file-like对象"></a>file-like对象</h4><p>类文件对象，可以像文件对象一样操作。</p>
<p>socket对象，输入输出对象（stdin、stdout）都是类文件对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> stdout, stderr</span><br><span class="line">f = stdout</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(f))  <span class="comment">#&lt;class &#x27;ipykernel.iostream.OutStream&#x27;&gt;</span></span><br><span class="line">f.write(<span class="string">&#x27;magedu.com&#x27;</span>)  <span class="comment">#magedu.com</span></span><br></pre></td></tr></table></figure>

<h4 id="路径操作"><a href="#路径操作" class="headerlink" title="路径操作"></a>路径操作</h4><h5 id="os-path模块"><a href="#os-path模块" class="headerlink" title="os.path模块"></a>os.path模块</h5><p>3.4版本之前</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> path</span><br><span class="line">p = path.join(<span class="string">&#x27;d:/&#x27;</span>,<span class="string">&#x27;tmp&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(p), p)               <span class="comment">#&lt;class &#x27;str&#x27;&gt; d:/tmp</span></span><br><span class="line"><span class="built_in">print</span>(path.exists(p))     <span class="comment">#判断是否存在该路径  True</span></span><br><span class="line"><span class="built_in">print</span>(path.split(p)) <span class="comment"># (head,tail)     (&#x27;d:/&#x27;, &#x27;tmp&#x27;)</span></span><br><span class="line"><span class="built_in">print</span>(path.abspath(<span class="string">&#x27;.&#x27;</span>))   <span class="comment"># 打印当前的绝对路径      C:\Users\vampire\python</span></span><br><span class="line">p = path.join(<span class="string">&#x27;D:/&#x27;</span>, p, <span class="string">&#x27;test.txt&#x27;</span>)   <span class="comment">#  &#x27;d:/tmp\\test.txt&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(path.dirname(p)) <span class="comment"># 目录名</span></span><br><span class="line"><span class="built_in">print</span>(path.basename(p)) <span class="comment">#基名，就是文件名</span></span><br><span class="line"><span class="built_in">print</span>(path.splitdrive(p)) <span class="comment">#二元组  (&#x27;d:&#x27;, &#x27;/tmp\\test.txt&#x27;）</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">p1 = path.abspath(<span class="string">&quot;.&quot;</span>)  <span class="comment">#“文件路径”</span></span><br><span class="line"><span class="built_in">print</span>(p1, path.basename(p1))</span><br><span class="line"><span class="keyword">while</span> p1 != path.dirname(p1):</span><br><span class="line">    p1 = path.dirname(p1)</span><br><span class="line">    <span class="built_in">print</span>(p1, path.basename(p1))</span><br><span class="line"></span><br><span class="line">​```</span><br><span class="line">C:\Users\vampire\python python</span><br><span class="line">C:\Users\vampire vampire</span><br><span class="line">C:\Users Users</span><br><span class="line">C:\ </span><br><span class="line">​```</span><br></pre></td></tr></table></figure>

<h5 id="pathlib模块"><a href="#pathlib模块" class="headerlink" title="pathlib模块"></a>pathlib模块</h5><p>提供Path对象来操作。包括目录和文件。</p>
<p>导入模块：from pathlib import Path</p>
<p><strong>目录操作初始化</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p = Path() <span class="comment"># 当前目录    WindowsPath(&#x27;.&#x27;)</span></span><br><span class="line">p.absolute()<span class="comment">#   WindowsPath(&#x27;C:/Users/vampire/python&#x27;)</span></span><br><span class="line">p = Path(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c/d&#x27;</span>) <span class="comment"># 当前目录下的 WindowsPath(&#x27;C:/Users/vampire/python/a/b/c/d&#x27;)</span></span><br><span class="line">p = Path(<span class="string">&#x27;/etc&#x27;</span>) <span class="comment"># 根下的etc目录</span></span><br></pre></td></tr></table></figure>

<p><strong>路径拼接和分解</strong></p>
<h6 id="操作符"><a href="#操作符" class="headerlink" title="操作符/"></a>操作符/</h6><p>Path对象 / Path对象<br>Path对象 / 字符串 或者 字符串 / Path对象 </p>
<h6 id="分解"><a href="#分解" class="headerlink" title="分解"></a>分解</h6><p>parts属性，可以返回路径中的每一个部分 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p3.absolute()   <span class="comment">#WindowsPath(&#x27;C:/Users/vampire/python/c/a&#x27;)</span></span><br><span class="line">p3.absolute().parts   <span class="comment">#(&#x27;C:\\&#x27;, &#x27;Users&#x27;, &#x27;vampire&#x27;, &#x27;python&#x27;, &#x27;c&#x27;, &#x27;a&#x27;)</span></span><br></pre></td></tr></table></figure>

<h6 id="joinpath"><a href="#joinpath" class="headerlink" title="joinpath"></a>joinpath</h6><p>joinpath(*other) 连接多个字符串到Path对象中</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">p = Path()   <span class="comment">#   WindowsPath(&#x27;.&#x27;)</span></span><br><span class="line">p = p / <span class="string">&#x27;a&#x27;</span>   <span class="comment">#  WindowsPath(&#x27;a&#x27;)</span></span><br><span class="line">p.absolute()  <span class="comment">#   WindowsPath(&#x27;C:/Users/vampire/python/a&#x27;)</span></span><br><span class="line">p1 = <span class="string">&#x27;b&#x27;</span> / p  <span class="comment">#   WindowsPath(&#x27;C:/Users/vampire/python/b/a&#x27;)</span></span><br><span class="line">p2 = Path(<span class="string">&#x27;c&#x27;</span>) <span class="comment">#  WindowsPath(&#x27;C:/Users/vampire/python/c&#x27;)</span></span><br><span class="line">p2.absolute()  <span class="comment">#   WindowsPath(&#x27;C:/Users/vampire/python/c&#x27;)</span></span><br><span class="line">p3 = p2 / p1  <span class="comment">#  WindowsPath(&#x27;c/b/a&#x27;)</span></span><br><span class="line">p3.absolute()  <span class="comment">#  WindowsPath(&#x27;C:/Users/vampire/python/c/b/a&#x27;)</span></span><br><span class="line"><span class="built_in">print</span>(p3.parts)   <span class="comment">#</span></span><br><span class="line">p3.absolute().parts <span class="comment"># (&#x27;C:\\&#x27;, &#x27;Users&#x27;, &#x27;vampire&#x27;, &#x27;python&#x27;, &#x27;c&#x27;, &#x27;b&#x27;, &#x27;a&#x27;)</span></span><br><span class="line">p3.joinpath(<span class="string">&#x27;etc&#x27;</span>,<span class="string">&#x27;init.d&#x27;</span>,Path(<span class="string">&#x27;httpd&#x27;</span>))</span><br></pre></td></tr></table></figure>

<h6 id="获取路径"><a href="#获取路径" class="headerlink" title="获取路径"></a>获取路径</h6><p>str 获取路径字符串 </p>
<p>bytes 获取路径字符串的bytes </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p = Path(<span class="string">&#x27;/etc&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(p), <span class="built_in">bytes</span>(p))</span><br><span class="line"></span><br><span class="line"><span class="comment">#  \etc   b&#x27;\\etc&#x27;</span></span><br></pre></td></tr></table></figure>

<h6 id="父目录"><a href="#父目录" class="headerlink" title="父目录"></a>父目录</h6><p>parent 目录的逻辑父目录 </p>
<p>parents 父目录序列，索引0是直接的父 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">p = Path(<span class="string">&#x27;/a/b/c/d&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(p.absolute())   <span class="comment">#C:\a\b\c\d</span></span><br><span class="line"><span class="built_in">print</span>(p.parent.parent)  <span class="comment">#\a\b</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> p.parents:</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line">    </span><br><span class="line"><span class="comment">#\a\b\c</span></span><br><span class="line"><span class="comment">#\a\b</span></span><br><span class="line"><span class="comment">#\a</span></span><br><span class="line"><span class="comment">#\</span></span><br></pre></td></tr></table></figure>

<h6 id="目录的组合部分"><a href="#目录的组合部分" class="headerlink" title="目录的组合部分"></a>目录的组合部分</h6><p>name、stem、suffix、suffixes、with_suffix(suffix)、with_name(name) </p>
<p>name 目录的最后一个部分 </p>
<p>suffix 目录中最后一个部分的扩展名 </p>
<p>stem 目录最后一个部分，没有后缀 </p>
<p>suffixes 返回多个扩展名列表 </p>
<p>with_suffix(suffix) 有扩展名则替换，无则补充扩展名 </p>
<p>with_name(name) 替换目录最后一个部分并返回一个新的路径</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">p = Path(<span class="string">&#x27;mysqlinstall/mysql.tar.gz&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(p.name)   <span class="comment">#mysql.tar.gz</span></span><br><span class="line"><span class="built_in">print</span>(p.suffix)  <span class="comment">#.gz</span></span><br><span class="line"><span class="built_in">print</span>(p.suffixes)  <span class="comment"># [&#x27;.tar&#x27;, &#x27;.gz&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(p.stem)   <span class="comment"># mysql.tar</span></span><br><span class="line"><span class="built_in">print</span>(p.with_name(<span class="string">&#x27;mysql-5.tgz&#x27;</span>))   <span class="comment">#\mysqlinstall\mysql-5.tgz</span></span><br><span class="line"><span class="built_in">print</span>(p.with_suffix(<span class="string">&#x27;.png&#x27;</span>))   <span class="comment">#\mysqlinstall\mysql.tar.png</span></span><br><span class="line">p = Path(<span class="string">&#x27;README&#x27;</span>)  <span class="comment">#  README</span></span><br><span class="line"><span class="built_in">print</span>(p.with_suffix(<span class="string">&#x27;.txt&#x27;</span>))   <span class="comment">#  README.txt</span></span><br></pre></td></tr></table></figure>

<h6 id="判断方法"><a href="#判断方法" class="headerlink" title="判断方法"></a>判断方法</h6><p><code>is_dir()</code> 是否是目录，目录存在返回True </p>
<p><code>is_file()</code> 是否是普通文件，文件存在返回True </p>
<p><code>is_symlink()</code> 是否是软链接 </p>
<p><code>is_socket() </code>是否是socket文件 </p>
<p><code>is_block_device() </code>是否是块设备 </p>
<p><code>is_char_device()</code> 是否是字符设备 </p>
<p><code>is_absolute() </code>是否是绝对路径</p>
<p><code>resolve() </code>返回一个新的路径，这个新路径就是当前Path对象的绝对路径，如果是软链接则直接被解析 </p>
<p><code>absolute()</code> 获取绝对路径</p>
<p><code>exists() </code>目录或文件是否存在 </p>
<p><code>rmdir() </code>删除空目录。没有提供判断目录为空的方法 </p>
<p><code>touch(mode=0o666, exist_ok=True)</code> 创建一个文件 </p>
<p><code>as_uri()</code> 将路径返回成URI，例如’file:///etc/passwd’</p>
<p><code>mkdir(mode=0o777, parents=False, exist_ok=False) </code></p>
<ul>
<li><p>parents，是否创建父目录，True等同于mkdir -p；False时，父目录不存在，则抛出FileNotFoundError </p>
</li>
<li><p>exist_ok参数，在3.5版本加入。False时，路径存在，抛出FileExistsError；True时，FileExistsError被忽略</p>
</li>
</ul>
<p><code>iterdir() </code>迭代当前目录</p>
<h6 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h6><p>match（pattern）</p>
<p>模式匹配，成功返回True。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Path(<span class="string">&#x27;a/b.py&#x27;</span>).match(<span class="string">&#x27;*.py&#x27;</span>) <span class="comment"># True</span></span><br><span class="line">Path(<span class="string">&#x27;/a/b/c.py&#x27;</span>).match(<span class="string">&#x27;b/*.py&#x27;</span>) <span class="comment"># True</span></span><br><span class="line">Path(<span class="string">&#x27;/a/b/c.py&#x27;</span>).match(<span class="string">&#x27;a/*.py&#x27;</span>) <span class="comment"># False</span></span><br><span class="line">Path(<span class="string">&#x27;/a/b/c.py&#x27;</span>).match(<span class="string">&#x27;a/*/*.py&#x27;</span>) <span class="comment"># True</span></span><br><span class="line">Path(<span class="string">&#x27;/a/b/c.py&#x27;</span>).match(<span class="string">&#x27;a/**/*.py&#x27;</span>) <span class="comment"># True</span></span><br><span class="line">Path(<span class="string">&#x27;/a/b/c.py&#x27;</span>).match(<span class="string">&#x27;**/*.py&#x27;</span>) <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<p>stat()  相当于stat命令  ，lstat() 同stat()，但如果是符号链接，则显示符号链接本身的文件信息</p>
<h6 id="pathlib模块下的文件操作"><a href="#pathlib模块下的文件操作" class="headerlink" title="pathlib模块下的文件操作"></a>pathlib模块下的文件操作</h6><p><code>Path.open(mode=&#39;r&#39;, buffering=-1, encoding=None, errors=None, newline=None)</code></p>
<p>使用的方法类似内建函数open，返回一个文件对象。</p>
<p>3.5增加的新函数 </p>
<p><code>Path.read_bytes()  </code></p>
<p>以’rb’读取路径对应文件，并返回二进制流。看源码</p>
<p><code>Path.read_text(encoding=None, errors=None) </code></p>
<p>以’rt’方式读取路径对应文件，返回文本。</p>
<p><code>Path.write_bytes(data)  </code></p>
<p>以’wb’方式写入数据到路径对应文件。</p>
<p><code>Path.write_text(data, encoding=None, errors=None) </code></p>
<p>以’wt’方式写入字符串到路径对应文件。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">p = Path(<span class="string">&#x27;my_binary_file&#x27;</span>)</span><br><span class="line">p.write_bytes(<span class="string">b&#x27;Binary file contents&#x27;</span>)</span><br><span class="line">p.read_bytes() <span class="comment"># b&#x27;Binary file contents&#x27;</span></span><br><span class="line"> </span><br><span class="line">p = Path(<span class="string">&#x27;my_text_file&#x27;</span>)</span><br><span class="line">p.write_text(<span class="string">&#x27;Text file contents&#x27;</span>)</span><br><span class="line">p.read_text() <span class="comment"># &#x27;Text file contents&#x27;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line">p = Path(<span class="string">&#x27;o:/test.py&#x27;</span>)</span><br><span class="line">p.write_text(<span class="string">&#x27;hello python&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(p.read_text())</span><br><span class="line"><span class="keyword">with</span> p.<span class="built_in">open</span>() <span class="keyword">as</span> f:</span><br><span class="line">    <span class="built_in">print</span>(f.read(<span class="number">5</span>))</span><br></pre></td></tr></table></figure>

<h4 id="csv文件"><a href="#csv文件" class="headerlink" title="csv文件"></a>csv文件</h4><p>逗号分隔值Comma-Separated Values。 </p>
<p>CSV 是一个被行分隔符、列分隔符划分成行和列的文本文件。 </p>
<p>CSV 不指定字符编码。</p>
<p>行分隔符为\r\n，最后一行可以没有换行符 </p>
<p>列分隔符常为逗号或者制表符。 </p>
<p>每一行称为一条记录record </p>
<p>字段可以使用双引号括起来，也可以不使用。如果字段中出现了双引号、逗号、换行符必须使用双引号括起来。如果字段的值是双引号，使用两个双引号表示一个转义。</p>
<p>表头可选，和字段列对齐就行了。</p>
<p>手动生成csv文件</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"></span><br><span class="line">p = Path(<span class="string">&#x27;D:/tmp/test.csv&#x27;</span>)</span><br><span class="line">parent = p.parent</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> parent.exists():</span><br><span class="line">    parent.mkdir(parents=<span class="literal">True</span>,exist_ok =<span class="literal">True</span>) <span class="comment">#exist_ok 用在python3.5之后，如果文件目录存在，True则压制异常。</span></span><br><span class="line">csv_body = <span class="string">&#x27;&#x27;&#x27;\</span></span><br><span class="line"><span class="string">id,name,age,comment</span></span><br><span class="line"><span class="string">1,zs,18,&quot;I&#x27;m 18&quot;</span></span><br><span class="line"><span class="string">2,ls,20,&quot;this is a &quot;&quot;test&quot;&quot; string.&quot;</span></span><br><span class="line"><span class="string">3,ww,23,&quot;你好</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">计算机</span></span><br><span class="line"><span class="string">&quot;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">p.write_text(csv_body)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="csv模块"><a href="#csv模块" class="headerlink" title="csv模块"></a>csv模块</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reader</span>(<span class="params">iterable, dialect=<span class="string">&#x27;excel&#x27;</span>, *args, **kwargs</span>)</span></span><br></pre></td></tr></table></figure>

<p>返回一个reader对象，是一个行迭代器</p>
<p>默认使用excel方言，如下：</p>
<ul>
<li><p>delimiter 列分隔符,逗号</p>
</li>
<li><p>lineterminator 行分隔符\r\n</p>
</li>
<li><p>quotechar 字段的引用符号，缺省为”双引号</p>
</li>
<li><p>双引号的处理</p>
<ul>
<li>doublequote 双引号的处理，默认为True。如果碰到数据中有双引号，而quotechar也是双引号，True则使用2个双引号表示，False表示使用转义字符将作为双引号的前缀。</li>
<li>escapechar 一个转义字符，默认为None</li>
<li>writer = csv.writer(f, doublequote=False, escapechar=‘@’) 遇到双引号，则必须提供转义字符</li>
</ul>
</li>
<li><p>quoting 指定双引号的规则</p>
<ul>
<li><p>QUOTE_ALL 所有字段</p>
</li>
<li><p>QUOTE_MINIMAL特殊字符字段，Excel方言使用该规则</p>
</li>
<li><p>QUOTE_NONNUMERIC非数字字段</p>
</li>
<li><p>QUOTE_NONE都不使用引号。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">writer</span>(<span class="params">fileobj, dialect=<span class="string">&#x27;excel&#x27;</span>, *args, **kwargs</span>)</span></span><br></pre></td></tr></table></figure>

<p>返回DictWriter实例，主要的方法有writerow，writerows。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"> </span><br><span class="line">p = Path(<span class="string">&#x27;d://tmp/tesr.csv&#x27;</span>)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="built_in">str</span>(p)) <span class="keyword">as</span> f:</span><br><span class="line">    reader = csv.reader(f)    <span class="comment">#返回一个迭代对象</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">next</span>(reader))     <span class="comment">#不回头</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">next</span>(reader))     </span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> reader:</span><br><span class="line">        <span class="built_in">print</span>(line)</span><br><span class="line"> </span><br><span class="line">rows = [</span><br><span class="line">    [<span class="number">4</span>,<span class="string">&#x27;tom&#x27;</span>,<span class="number">22</span>,<span class="string">&#x27;tom&#x27;</span>],</span><br><span class="line">    (<span class="number">5</span>,<span class="string">&#x27;jerry&#x27;</span>,<span class="number">24</span>,<span class="string">&#x27;jerry&#x27;</span>),</span><br><span class="line">    (<span class="number">6</span>,<span class="string">&#x27;justin&#x27;</span>,<span class="number">22</span>,<span class="string">&#x27;just\t&quot;in&#x27;</span>),</span><br><span class="line">    <span class="string">&quot;abcdefghi&quot;</span>,</span><br><span class="line">    ((<span class="number">1</span>,),(<span class="number">2</span>,))</span><br><span class="line">]</span><br><span class="line">row = rows[<span class="number">0</span>]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="built_in">str</span>(p), <span class="string">&#x27;a&#x27;</span>,newline=<span class="string">&quot;&quot;</span>) <span class="keyword">as</span> f:  <span class="comment">#newline为了不换行</span></span><br><span class="line">    writer = csv.writer(f)</span><br><span class="line">    writer.writerow(row)   <span class="comment">#一次写一条</span></span><br><span class="line">    writer.writerows(rows)    <span class="comment">#将所有的一次写入</span></span><br></pre></td></tr></table></figure>

<h4 id="ini文件"><a href="#ini文件" class="headerlink" title="ini文件"></a>ini文件</h4><p>一般作为配置文件。</p>
<p>ini文件：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[DEFAULT]</span></span><br><span class="line"><span class="attr">a</span> = test</span><br><span class="line"> </span><br><span class="line"><span class="section">[mysql]</span></span><br><span class="line"><span class="attr">default-character-set</span>=utf8</span><br><span class="line"> </span><br><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">datadir</span> =/dbserver/data</span><br><span class="line"><span class="attr">port</span> = <span class="number">33060</span></span><br><span class="line"><span class="attr">character-set-server</span>=utf8</span><br><span class="line"><span class="attr">sql_mode</span>=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES</span><br></pre></td></tr></table></figure>

<p>中括号里面的部分称为section，译作节、区、段。 </p>
<p>每一个section内，都是key=value形成的键值对，key称为option选项。</p>
<p>这里的DEFAULT是缺省section的名字，必须大写。</p>
<h5 id="configparser模块"><a href="#configparser模块" class="headerlink" title="configparser模块"></a>configparser模块</h5><p>configparser模块的ConfigParser类就是用来操作。</p>
<p>可以将section当做key，section存储着键值对组成的字典，可以把ini配置文件当做一个嵌套的字典。默认使用的是有序字典。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">read(filenames, encoding=<span class="literal">None</span>) </span><br><span class="line"><span class="comment">#读取ini文件，可以是单个文件，也可以是文件列表。可以指定文件编码。</span></span><br><span class="line">sections()  <span class="comment">#返回section列表。缺省section不包括在内。 </span></span><br><span class="line">add_section(section_name)   <span class="comment">#增加一个section。 </span></span><br><span class="line"></span><br><span class="line">has_section(section_name)   <span class="comment">#判断section是否存在 </span></span><br><span class="line">options(section)   <span class="comment">#返回section的所有option，会追加缺省section的option </span></span><br><span class="line"></span><br><span class="line">has_option(section, option)  <span class="comment">#判断section是否存在这个option</span></span><br><span class="line">get(section, option, *, raw=<span class="literal">False</span>, <span class="built_in">vars</span>=<span class="literal">None</span>[, fallback]) </span><br><span class="line"></span><br><span class="line"><span class="comment">#从指定的段的选项上取值，如果找到返回，如果没有找到就去找DEFAULT段有没有。</span></span><br><span class="line"></span><br><span class="line">getint(section, option, *, raw=<span class="literal">False</span>, <span class="built_in">vars</span>=<span class="literal">None</span>[, fallback]) </span><br><span class="line">getfloat(section, option, *, raw=<span class="literal">False</span>, <span class="built_in">vars</span>=<span class="literal">None</span>[, fallback]) </span><br><span class="line">getboolean(section, option, *, raw=<span class="literal">False</span>, <span class="built_in">vars</span>=<span class="literal">None</span>[, fallback]) </span><br><span class="line"><span class="comment">#上面3个方法和get一样，返回指定类型数据。</span></span><br><span class="line"></span><br><span class="line">items(raw=<span class="literal">False</span>, <span class="built_in">vars</span>=<span class="literal">None</span>) </span><br><span class="line">items(section, raw=<span class="literal">False</span>, <span class="built_in">vars</span>=<span class="literal">None</span>) </span><br><span class="line"><span class="comment">#没有section，则返回所有section名字及其对象；如果指定section，则返回这个指定的section的键值对组成二元组。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>(section, option, value) </span><br><span class="line"><span class="comment">#section存在的情况下，写入option=value，要求option、value必须是字符串。</span></span><br><span class="line"></span><br><span class="line">remove_section(section) </span><br><span class="line"><span class="comment">#移除section及其所有option </span></span><br><span class="line"></span><br><span class="line">remove_option(section, option) </span><br><span class="line"><span class="comment">#移除section下的option。</span></span><br><span class="line"></span><br><span class="line">write(fileobject, space_around_delimiters=<span class="literal">True</span>) </span><br><span class="line"><span class="comment">#将当前config的所有内容写入fileobject中，一般open函数使用w模式。</span></span><br></pre></td></tr></table></figure>
<p>代码示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> configparser <span class="keyword">import</span> ConfigParser</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"></span><br><span class="line">filename = Path(<span class="string">&quot;d://tmp/mysql.ini&quot;</span>)</span><br><span class="line">newfilename = Path(<span class="string">&quot;d://tmp/mysql111.ini&quot;</span>)</span><br><span class="line"></span><br><span class="line">cfg = ConfigParser()</span><br><span class="line">read_ok = cfg.read(<span class="built_in">str</span>(filename))</span><br><span class="line"><span class="built_in">print</span>(read_ok)</span><br><span class="line"><span class="built_in">print</span>(cfg.sections())</span><br><span class="line"><span class="built_in">print</span>(cfg.has_section(<span class="string">&quot;mysql&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-&quot;</span>*<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> cfg.items():   <span class="comment">#未指定section</span></span><br><span class="line">    <span class="built_in">print</span>(k,<span class="built_in">type</span>(k))</span><br><span class="line">    <span class="built_in">print</span>(v,<span class="built_in">type</span>(v))</span><br><span class="line">    <span class="built_in">print</span>(cfg.items(k))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;~~~~~~~~~~~~~~~~~~&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-&quot;</span>*<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> cfg.items(<span class="string">&quot;mysqld&quot;</span>):  <span class="comment">#指定section</span></span><br><span class="line">    <span class="built_in">print</span>(k,<span class="built_in">type</span>(k))</span><br><span class="line">    <span class="built_in">print</span>(v,<span class="built_in">type</span>(v))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;~~~~~~~~~~&quot;</span>)</span><br><span class="line"></span><br><span class="line">tmp = cfg.get(<span class="string">&quot;mysqld&quot;</span>,<span class="string">&quot;port&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(tmp, <span class="built_in">type</span>(tmp))</span><br><span class="line"><span class="built_in">print</span>(cfg.get(<span class="string">&quot;mysqld&quot;</span>, <span class="string">&quot;a&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(cfg.get(<span class="string">&quot;mysqld&quot;</span>, <span class="string">&quot;python&quot;</span> , fallback= <span class="string">&quot;linux&quot;</span>))  <span class="comment">#按照类型，fallbac：给与缺省值</span></span><br><span class="line"></span><br><span class="line">tmp = cfg.getint(<span class="string">&quot;mysqld&quot;</span>, <span class="string">&quot;port&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(tmp), tmp)</span><br><span class="line"></span><br><span class="line">cfg.add_section(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">cfg.<span class="built_in">set</span>(<span class="string">&quot;test&quot;</span>,<span class="string">&quot;test1&quot;</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line">cfg.<span class="built_in">set</span>(<span class="string">&quot;test&quot;</span>,<span class="string">&quot;test2&quot;</span>,<span class="string">&quot;2&quot;</span>)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(newfilename,<span class="string">&quot;w+&quot;</span>,newline=<span class="string">&quot;&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    cfg.write(f)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(cfg.getint(<span class="string">&quot;test&quot;</span> , <span class="string">&quot;test1&quot;</span>))</span><br><span class="line"></span><br><span class="line">cfg.remove_option(<span class="string">&quot;test&quot;</span>, <span class="string">&quot;test1&quot;</span>)</span><br><span class="line"><span class="comment"># cfg.remove_section(&quot;test&quot;)</span></span><br><span class="line"><span class="comment"># print(&quot;x&quot; in cfg[&quot;test2&quot;])</span></span><br><span class="line"><span class="comment">#字典操作</span></span><br><span class="line">cfg[<span class="string">&quot;test3&quot;</span>] = &#123;<span class="string">&quot;c&quot;</span>:<span class="string">&quot;1000&quot;</span>&#125;   <span class="comment">#没有落地，在内存中修改</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x&quot;</span> <span class="keyword">in</span> cfg[<span class="string">&quot;test&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c&quot;</span> <span class="keyword">in</span> cfg[<span class="string">&quot;test3&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 其他内部方式</span></span><br><span class="line"><span class="built_in">print</span>(cfg._<span class="built_in">dict</span>)  <span class="comment"># 返回默认的字典类型，默认使用有序字典</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> cfg._sections.items():</span><br><span class="line">    <span class="built_in">print</span>(k, v)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> cfg._sections[<span class="string">&#x27;mysqld&#x27;</span>].items():</span><br><span class="line">    <span class="built_in">print</span>(k,v)</span><br><span class="line"><span class="comment">#重新写入文件</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(newfilename, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    cfg.write(f)</span><br></pre></td></tr></table></figure>



<h4 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h4><pre><code>要设计一套协议，按照某种规则，把内存中数据保存到文件中，文件是一个字节序列，所以必须把数据转换成&lt;font color=red &gt;字节&lt;/font&gt;序列，输出到文件。这就是序列化。反之，从文件的字节序列恢复到内存。就是反序列化。
</code></pre>
<ol>
<li><p>serialization：序列化<br>将内存中对象存储下来，变成一个个字节 –&gt;  二进制</p>
</li>
<li><p>deseiralization：反序列化<br>将文件中的一个个字节恢复成内存中对象   &lt;–二进制</p>
</li>
</ol>
<p>序列化保存到文件就是持久化，可以将数据序列化后持久化，或者网络传输；也可以将文件中或者网络中接收到的字节序列反序列化。</p>
<h5 id="pickle库"><a href="#pickle库" class="headerlink" title="pickle库"></a>pickle库</h5><p>python中的序列化，反序列化模块。</p>
<p>dumps  对象序列化为bytes对象      dump   对象序列化到文件对象，就是存入文件</p>
<p>loads 从bytes对象反序列化     load  对象反序列化，从文件读取数据</p>
<h5 id="序列化的应用"><a href="#序列化的应用" class="headerlink" title="序列化的应用"></a>序列化的应用</h5><p>一般来说，本地序列化的情况，应用较少。大多数场景都应用在网络传输中。 </p>
<p>将数据序列化后通过网络传输到远程节点，远程服务器上的服务将接收到的数据反序列化后，就可以使用了。 </p>
<p>但是，要注意一点，远程接收端，反序列化时必须有对应的数据类型，否则就会报错。尤其是自定义类，必须远程的有一致的定义。</p>
<p>现在，大多数项目，都不是单机的，也不是单服务的。需要通过网络将数据传送到其他节点上去，这就需要大量的序列化、反序列化过程。</p>
<p>但是，问题是，Python程序之间还可以都是用pickle解决序列化、反序列化，如果是跨平台、跨语言、跨协议pickle就不太适合了，就需要公共的协议。例如XML、Json、Protocol Buffer等。</p>
<p>不同的协议，效率不同、学习曲线不同，适用不同场景，要根据不同的情况分析选型。</p>
<h5 id="Json"><a href="#Json" class="headerlink" title="Json"></a>Json</h5><pre><code>Json(JavaScript Object Notation，JS对象标记)是一种轻量级的数据交换格式。它基于 ECMAScript (w3c组织制定的JS规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。网址: http://json.org/
</code></pre>
<p>Json的数据类型</p>
<p>值：双引号引起来的字符串，数值，true和false，null，对象，数组，这些都是值 </p>
<p>字符串：有正负，有整数，浮点数。</p>
<p>对象：无序的键值对的集合，格式{key:value…}，key必须是一个字符串，需要双引号包围这个字符串，value可以是任意合法的值。</p>
<p>数组：有序的值的集合  格式[val1，，，，valn]</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;person&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;tom&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;age&quot;</span>: <span class="number">18</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;jerry&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;age&quot;</span>: <span class="number">16</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;total&quot;</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Json模块</p>
<p>Python支持少量内建数据类型到Json类型的转换</p>
<table>
<thead>
<tr>
<th>Python类型</th>
<th>Json类型</th>
</tr>
</thead>
<tbody><tr>
<td>True</td>
<td>true</td>
</tr>
<tr>
<td>False</td>
<td>false</td>
</tr>
<tr>
<td>None</td>
<td>null</td>
</tr>
<tr>
<td>str</td>
<td>string</td>
</tr>
<tr>
<td>int</td>
<td>integer</td>
</tr>
<tr>
<td>float</td>
<td>float</td>
</tr>
<tr>
<td>list</td>
<td>array</td>
</tr>
<tr>
<td>dict</td>
<td>object</td>
</tr>
</tbody></table>
<p>常用方法</p>
<table>
<thead>
<tr>
<th>Python类型</th>
<th>Json类型</th>
</tr>
</thead>
<tbody><tr>
<td>dumps</td>
<td>Json编码</td>
</tr>
<tr>
<td>dump</td>
<td>Json编码并存入文件</td>
</tr>
<tr>
<td>loads</td>
<td>Json解码</td>
</tr>
<tr>
<td>load</td>
<td>Json解码，从文件读取数据</td>
</tr>
</tbody></table>
<p>一般Json编码的数据很少落地，数据都是通过网络传输，传输的时候，要考虑压缩它，节省流量。本质来说它就是个文本，就是个字符串。</p>
<h5 id="MessagePack"><a href="#MessagePack" class="headerlink" title="MessagePack"></a>MessagePack</h5><p>MessagePack是一个基于二进制高效的对象序列化类库，可用于跨语言通信。 </p>
<p>它可以像JSON那样，在许多种语言之间交换结构对象。 </p>
<p>兼容 json和pickle。</p>
<p>MessagePack简单易用，高效压缩，支持语言丰富。 </p>
<p>所以，用它序列化也是一种很好的选择。</p>
<p>安装：$pip install msgpack-python</p>
<p>常用方法：</p>
<p>packb 序列化对象。提供了dumps来兼容pickle和json。 </p>
<p>unpackb 反序列化对象。提供了loads来兼容。</p>
<p>pack 序列化对象保存到文件对象。提供了dump来兼容。</p>
<p>unpack 反序列化对象保存到文件对象。提供了load来兼容。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> msgpack</span><br><span class="line"></span><br><span class="line">d = &#123;<span class="string">&quot;person&quot;</span>:[&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;tom&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">18</span>&#125;,&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;jerry&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">16</span>&#125;],<span class="string">&quot;total&quot;</span>:<span class="number">2</span>&#125;</span><br><span class="line">j = json.dumps(d)</span><br><span class="line"><span class="built_in">print</span>(j, <span class="built_in">type</span>(j), <span class="built_in">len</span>(j)) <span class="comment"># 请注意引号的变化</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(j.replace(<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;&#x27;</span>))) <span class="comment"># 72 bytes 注意这样替换的压缩是不对的</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-&quot;</span>*<span class="number">30</span>)</span><br><span class="line">p = pickle.dumps(d)</span><br><span class="line"><span class="built_in">print</span>(p)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(p))  <span class="comment"># 101 bytes</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-&quot;</span>*<span class="number">30</span>)</span><br><span class="line">m = msgpack.dumps(d)</span><br><span class="line"><span class="built_in">print</span>(m)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(m)) <span class="comment"># 48 bytes</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-&quot;</span>*<span class="number">30</span>)</span><br><span class="line">u = msgpack.unpackb(m)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(u), u)</span><br><span class="line">u = msgpack.loads(m, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(u), u)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;person&quot;: [&#123;&quot;name&quot;: &quot;tom&quot;, &quot;age&quot;: 18&#125;, &#123;&quot;name&quot;: &quot;jerry&quot;, &quot;age&quot;: 16&#125;], &quot;total&quot;: 2&#125; &lt;class &#x27;str&#x27;&gt; 82</span><br><span class="line">72</span><br><span class="line">------------------------------</span><br><span class="line">b&#x27;\x80\x03&#125;q\x00(X\x06\x00\x00\x00personq\x01]q\x02(&#125;q\x03(X\x04\x00\x00\x00nameq\x04X\x03\x00\x00\x00tomq\x05X\x03\x00\x00\x00ageq\x06K\x12u&#125;q\x07(h\x04X\x05\x00\x00\x00jerryq\x08h\x06K\x10ueX\x05\x00\x00\x00totalq\tK\x02u.&#x27;</span><br><span class="line">101</span><br><span class="line">------------------------------</span><br><span class="line">b&#x27;\x82\xa6person\x92\x82\xa4name\xa3tom\xa3age\x12\x82\xa4name\xa5jerry\xa3age\x10\xa5total\x02&#x27;</span><br><span class="line">48</span><br><span class="line">------------------------------</span><br><span class="line">&lt;class &#x27;dict&#x27;&gt; &#123;b&#x27;person&#x27;: [&#123;b&#x27;name&#x27;: b&#x27;tom&#x27;, b&#x27;age&#x27;: 18&#125;, &#123;b&#x27;name&#x27;: b&#x27;jerry&#x27;, b&#x27;age&#x27;: 16&#125;], b&#x27;total&#x27;: 2&#125;</span><br><span class="line">&lt;class &#x27;dict&#x27;&gt; &#123;&#x27;person&#x27;: [&#123;&#x27;name&#x27;: &#x27;tom&#x27;, &#x27;age&#x27;: 18&#125;, &#123;&#x27;name&#x27;: &#x27;jerry&#x27;, &#x27;age&#x27;: 16&#125;], &#x27;total&#x27;: 2&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://vampireqian.github.io/2017/09/10/10python%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E3%80%81%E8%B7%AF%E5%BE%84%E5%A4%84%E7%90%86%E3%80%81%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" data-id="ckxlw2jbh000m0zex5je5hu8u" data-title="python-文件处理、路径处理、序列化和反序列化" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/" rel="tag">python</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-08python函数、高阶函数、装饰器、参数注解、缓存" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2017/08/21/08python%E5%87%BD%E6%95%B0%E3%80%81%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E3%80%81%E8%A3%85%E9%A5%B0%E5%99%A8%E3%80%81%E5%8F%82%E6%95%B0%E6%B3%A8%E8%A7%A3%E3%80%81%E7%BC%93%E5%AD%98/" class="article-date">
  <time class="dt-published" datetime="2017-08-20T16:00:00.000Z" itemprop="datePublished">2017-08-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/python/">python</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2017/08/21/08python%E5%87%BD%E6%95%B0%E3%80%81%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E3%80%81%E8%A3%85%E9%A5%B0%E5%99%A8%E3%80%81%E5%8F%82%E6%95%B0%E6%B3%A8%E8%A7%A3%E3%80%81%E7%BC%93%E5%AD%98/">python-函数、高阶函数、装饰器、参数注解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><hr>
<h4 id="1-函数的定义"><a href="#1-函数的定义" class="headerlink" title="1. 函数的定义"></a>1. 函数的定义</h4><hr>
<p>由若干语句组成的语句块、函数名称、参数列表构成，它是组织代码的最小单元。</p>
<p>完成一定的功能。</p>
<p>函数也是对象，python把函数的默认值放在了属性中，这个属性就伴随着这个函数对象的整个生命周期。</p>
<h4 id="2-函数的作用"><a href="#2-函数的作用" class="headerlink" title="2.  函数的作用"></a>2.  函数的作用</h4><hr>
<ul>
<li>结构化编程是对代码的最基本的<font color = red >封装</font>，一般按照功能组织一段代码。</li>
<li>封装的目的是为了<font color = red >复用</font>，减少冗余代码。</li>
<li>代码更加简洁美观，可读易懂。</li>
</ul>
<h4 id="3-函数的分类："><a href="#3-函数的分类：" class="headerlink" title="3. 函数的分类："></a>3. 函数的分类：</h4><hr>
<p>内建函数；库函数；自建函数</p>
<h4 id="4-函数的定义、调用"><a href="#4-函数的定义、调用" class="headerlink" title="4. 函数的定义、调用"></a>4. 函数的定义、调用</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><hr>
<p>def语句定义函数</p>
<p>def 函数名（参数列表）：</p>
<pre><code>函数体（代码块）

[return 返回值]
</code></pre>
<p>定义中的参数列表成为形式参数，只是一种符号表达，简称<strong>形参</strong>。</p>
<p>定义需要在调用前，否则会抛出NameError异常。</p>
<h5 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h5><hr>
<p>函数定义，只是声明了一个函数，它不会被指执行，需要调用。</p>
<p>调用的方式，就是函数名加上小括号，括号内写上参数。</p>
<p>调用时写的参数时实际参数，是实实在在传入的值，简称<strong>实参</strong></p>
<p>传参时位置参数要放在关键字参数前面。</p>
<p>参数传递：不可变类型，传递副本给函数，函数内操作不影响原始值</p>
<pre><code> 可变类型，传递的是地址引用，函数内操作可能影响原始值
</code></pre>
<h5 id="定义形参和传递实参时候的注意事项"><a href="#定义形参和传递实参时候的注意事项" class="headerlink" title="定义形参和传递实参时候的注意事项"></a>定义形参和传递实参时候的注意事项</h5><hr>
<ol>
<li>参数调用时传入的参数要和定义的个数相匹配，可变参数例外</li>
<li>定义时，缺省参数要放在非缺省参数前。</li>
<li>定义时加* ：可变位置参数：可以收集位置参数传入的所有参数，收集多个实参为一个tuple。可变位置参数不能用关键字传参。</li>
<li>形参加**：可变关键字参数，只能用关键字传参。可变关键字参数，收集的实参名称和值组成一个字典，所以可修改。</li>
<li>函数名也是标识符，返回值也是值，函数是可调用的对象，callable(函数名)  -&gt; True。</li>
<li>混合使用参数的时候，可变参数要放到参数列表的最后，普通参数要放到参数列表的最前面，可变位置参数发要放在可变关键字参数的前面。</li>
<li>keyword-only参数：如果在一个可变位置参数后面，出现了普通参数，此时这个普通参数已经变成了一个keyword-only参数</li>
<li>参数列表参数一般顺序是，普通参数、缺省参数、可变位置参数、keyword-only参数（可带缺省值）、可变关键字参数。</li>
<li>参数解构：<ul>
<li>给函数提供实参的时候，可以在集合类型前使用*或者**，把集合类型的结构解开，提取出所有元素作为函数的实参。</li>
<li>非字典类型使用*解构成位置参数</li>
<li>字典类型使用**解构成关键字参数</li>
<li>提取出来的元素数目要和参数的要求匹配，也要和参数的类型匹配。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="5-函数的返回值"><a href="#5-函数的返回值" class="headerlink" title="5.函数的返回值"></a>5.函数的返回值</h4><p>python函数使用return语句返回“返回值”。</p>
<p>所有函数都有返回值。如果没有return语句，隐式调用return None。</p>
<p>return语句并不一定是函数的语句块的最后一条语句</p>
<p>return语句只能执行一次，执行完，函数结束，当前return后面的语句就不会再运行了。所以函数一次只能返回一个值，不能返回多个值，但是可以返回容器，容器里面包含多个值。（return [1,3,5]是指明返回一个列表，是一个列表对象；return 1,3,5看似返回多个值，隐式的被python封装成一个元组）</p>
<p>作用：结束函数调用、返回值。</p>
<h5 id="函数的嵌套"><a href="#函数的嵌套" class="headerlink" title="函数的嵌套"></a>函数的嵌套</h5><hr>
<p>函数有可见范围。这就是<strong>作用域</strong>的概念</p>
<p>外层变量作用域在内层作用域可见</p>
<p>内部函数不能在外部直接使用，会抛NameError异常，因为它不可见。</p>
<h4 id="6-作用域"><a href="#6-作用域" class="headerlink" title="6. 作用域"></a>6. 作用域</h4><hr>
<p>一个标识符的可见范围，这就是标识符的作用域。一般常说的是变量的作用域。</p>
<p>全局作用域：在整个函数运行环境中都可见。</p>
<p>局部作用域：在函数、类内部可见；局部变量的使用范围不能超过其所在的局部作用域。</p>
<p>例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">5</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">    a += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">UnboundLocalError                         Traceback (most recent call last)</span><br><span class="line">UnboundLocalError: local variable <span class="string">&#x27;a&#x27;</span> referenced before assignment</span><br></pre></td></tr></table></figure>

<p>报错原因：</p>
<pre><code>a += 1其实就是a = a + 1,a = 5是全局的变量，虽然能在内部函数foo中可见，但是在foo函数内部出现了 a = ，出现等号就是即赋值即重新定义，那么=的右边作为赋值的内容 ：a+1,但在函数中，此时的a已经算是重新定义了一个局部变量，而不是用外面的全局变量，但是此时a还没有完成赋值就被拿来进行加1操作，所以才会报错。
</code></pre>
<p> 解决办法：</p>
<pre><code>在这条语句前增加x=0之类的赋值语句，或者使用global 告诉内部作用域，去全局作用域查找变量定义
</code></pre>
<h5 id="默认值的作用域"><a href="#默认值的作用域" class="headerlink" title="默认值的作用域"></a>默认值的作用域</h5><hr>
<p>函数名.__defaults__属性：使用元组来保存所有位置参数默认值，它不会因为在函数体中使用了它而发生了变化。</p>
<p>函数名.__kwdefaults__属性：使用字典保存所有keyword-only参数的默认值。</p>
<p>使用可变类型（引用参数）作为默认值，就有可能修改这个默认值。</p>
<p>使用按需修改,例子。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">xyz=[], u=<span class="string">&#x27;abc&#x27;</span>, z=<span class="number">123</span></span>):</span></span><br><span class="line">    xyz = xyz[:] <span class="comment"># 影子拷贝</span></span><br><span class="line">    xyz.append(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(xyz)</span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line"><span class="built_in">print</span>(foo.__defaults__)</span><br><span class="line">foo([<span class="number">10</span>])</span><br><span class="line"><span class="built_in">print</span>(foo.__defaults__)</span><br><span class="line">foo([<span class="number">10</span>,<span class="number">5</span>])</span><br><span class="line"><span class="built_in">print</span>(foo.__defaults__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数体内，不改变默认值</span></span><br><span class="line"><span class="comment"># 使用影子拷贝创建一个新的对象，永远不能改变传入的参数</span></span><br><span class="line"><span class="comment"># xyz都是传入参数或者默认参数的副本，如果就想修改原参数，无能为力</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">xyz=<span class="literal">None</span>, u=<span class="string">&#x27;abc&#x27;</span>, z=<span class="number">123</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> xyz <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    	xyz = []</span><br><span class="line">    xyz.append(<span class="number">1</span>) </span><br><span class="line">    <span class="built_in">print</span>(xyz)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用不可变类型默认值</span></span><br><span class="line"><span class="comment"># 如果使用缺省值None就创建一个列表</span></span><br><span class="line"><span class="comment"># 如果传入一个列表，就修改这个列表</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="全局变量global"><a href="#全局变量global" class="headerlink" title="全局变量global"></a>全局变量global</h5><p>使用global关键字的变量，将函数内的定义的局部变量声明成全局变量。</p>
<p> 如果函数需要使用外部全局变量，请使用函数的形参传参解决。</p>
<p>尽量不使用</p>
<h5 id="nonlocal关键字"><a href="#nonlocal关键字" class="headerlink" title="nonlocal关键字"></a>nonlocal关键字</h5><p>nonlocal将变量标记为不再本地作用域定义，而在<font color =red>上一级的某一级</font>局部作用域中定义，但不能是全局作用域中定义。</p>
<h4 id="7-闭包"><a href="#7-闭包" class="headerlink" title="7.闭包"></a>7.<font color = blue>闭包</font></h4><p>自由变量：未在本地作用域中定义的变量，例如定义在内层函数外的外层函数的作用域中的变量</p>
<p><font color = red >闭包</font>：是一概念，是嵌套函数中，指的是在内层函数中引用到外层函数的自由变量，就形成了闭包。</p>
<h4 id="8-变量名解析原则LEGB"><a href="#8-变量名解析原则LEGB" class="headerlink" title="8.变量名解析原则LEGB"></a>8.变量名解析原则LEGB</h4><ul>
<li><p>Local，本地作用域、局部作用域的local命名空间。函数调用时创建，调用结束消亡。</p>
</li>
<li><p>Enclosing，Python2.2时引入了嵌套函数，实现了闭包，这个就是嵌套函数的外部函数的命名空间。</p>
</li>
<li><p>Global，全局作用域，即一个模块的命名空间。模块被import时创建，解释器退出时消亡。</p>
</li>
<li><p>Build-in，内置模块的命名空间，生命周期从python解释器启动时创建到解释器退出时消亡。例如 print(open)，print和open都是内置的变量。</p>
</li>
</ul>
<p>函数变量作用域：级别：Built_in(内建)  &gt; Global(全局) &gt;   Enclosing（封装）&gt; local(本地)</p>
<h4 id="9-函数的销毁"><a href="#9-函数的销毁" class="headerlink" title="9.函数的销毁"></a>9.函数的销毁</h4><h5 id="全局函数销毁"><a href="#全局函数销毁" class="headerlink" title="全局函数销毁"></a>全局函数销毁</h5><ol>
<li>重新定义同名函数</li>
<li>del 语句删除函数对象名称，函数对象的引用计数减1</li>
<li>程序结束时</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">xyz=[], u=<span class="string">&#x27;abc&#x27;</span>, z=<span class="number">123</span></span>):</span></span><br><span class="line">    xyz.append(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> xyz</span><br><span class="line"><span class="built_in">print</span>(foo(), <span class="built_in">id</span>(foo), foo.__defaults__)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">xyz=[], u=<span class="string">&#x27;abc&#x27;</span>, z=<span class="number">123</span></span>):</span></span><br><span class="line">    xyz.append(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> xyz</span><br><span class="line"><span class="built_in">print</span>(foo(), <span class="built_in">id</span>(foo), foo.__defaults__)</span><br><span class="line"><span class="keyword">del</span> foo</span><br><span class="line"><span class="built_in">print</span>(foo(), <span class="built_in">id</span>(foo), foo.__defaults__)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="局部函数销毁"><a href="#局部函数销毁" class="headerlink" title="局部函数销毁"></a>局部函数销毁</h5><ol>
<li>重新在上级作用域定义同名函数</li>
<li>del 语句删除函数名称，函数对象的引用计数减1</li>
<li>上级作用域销毁时</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">xyz=[], u=<span class="string">&#x27;abc&#x27;</span>, z=<span class="number">123</span></span>):</span></span><br><span class="line">    xyz.append(<span class="number">1</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span>(<span class="params">a=<span class="number">10</span></span>):</span></span><br><span class="line">    	<span class="keyword">pass</span></span><br><span class="line">    <span class="built_in">print</span>(inner)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span>(<span class="params">a=<span class="number">100</span></span>):</span></span><br><span class="line">        <span class="built_in">print</span>(xyz)</span><br><span class="line">    <span class="built_in">print</span>(inner)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line">bar = foo()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(foo),<span class="built_in">id</span>(bar), foo.__defaults__, bar.__defaults__)</span><br><span class="line"><span class="keyword">del</span> bar</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(foo),<span class="built_in">id</span>(bar), foo.__defaults__, bar.__defaults__)</span><br></pre></td></tr></table></figure>
<h4 id="10-递归函数"><a href="#10-递归函数" class="headerlink" title="10.递归函数"></a>10.递归函数</h4><p>函数是需要压栈的，栈和线程相关。</p>
<h4 id="11-匿名函数"><a href="#11-匿名函数" class="headerlink" title="11.匿名函数"></a>11.匿名函数</h4><p>没有名字的函数，python借助lamdba表达式构建匿名函数。</p>
<p>参数列表不需要小括号。</p>
<p>冒号是用来区分参数列表和表达式的。</p>
<p>不需要return，表达式的值，就是匿名函数返回值。</p>
<p>lambda表达式（匿名函数）只能写在一行上，被成为单行函数。</p>
<p>用途：在高阶函数传参时，使用lambda表达式，往往能简化代码</p>
<p>格式：lambda 参数列表：表达式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lambda</span> x :  x**<span class="number">2</span></span><br><span class="line"></span><br><span class="line">(<span class="keyword">lambda</span> x :  x**<span class="number">2</span>) ()  <span class="comment">#调用</span></span><br></pre></td></tr></table></figure>

<h4 id="12-高阶函数"><a href="#12-高阶函数" class="headerlink" title="12.高阶函数"></a>12.高阶函数</h4><p>FIrst Class Object</p>
<p>函数也是对象，可调用对象</p>
<p>函数可以作为普通变量、参数、返回值等等。</p>
<p>高阶函数，至少满足下面的一个条件的函数。</p>
<p>接收一个或者多个函数作为参数，或者函数的输出是一个函数。</p>
<h4 id="13-装饰器"><a href="#13-装饰器" class="headerlink" title="13.装饰器"></a>13.装饰器</h4><p>装饰器本质上是一个 Python 函数或类。</p>
<p>它可以让其他函数或类在不需要做任何代码修改的前提下增加额外功能，装饰器的返回值也是一个函数/类对象。它经常用于有切面需求的场景，比如：插入日志、性能测试、事务处理、缓存、权限校验等场景，装饰器是解决这类问题的绝佳设计。有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码到装饰器中并继续重用。概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能。 </p>
<p>多装饰器的函数执行顺序，由底向上</p>
<h4 id="14-参数注解"><a href="#14-参数注解" class="headerlink" title="14.参数注解"></a>14.参数注解</h4><p>文档注解：函数内的最前面，使用三个双引号</p>
<p>函数注解：</p>
<ul>
<li>python3.5引入</li>
<li>对函数的参数进行类型注解</li>
<li>对函数的返回值进行类型注解</li>
<li>只对函数参数做一个辅助的说明，并不对函数参数进行类型检查</li>
<li>提供给第三方工具，做代码分析，发现隐藏的bug</li>
<li>函数注解的信息，保存在__annotations__属性中</li>
</ul>
<p>变量注解：python3.6引入</p>
<p><strong>函数参数类型检查</strong></p>
<p>思路：</p>
<ul>
<li>函数参数的检查，一定是在函数外</li>
<li>函数应该作为参数，传入到检查函数中</li>
<li>检查函数拿到函数传入的实际参数，与形参声明对比</li>
<li>__annotations__属性是一个字典，其中包括返回值类型的声明，加入要位置参数的判断，无法和字典中的声明对应，使用inspect模块</li>
</ul>
<p>inspect模块：提取获取对象信息的函数，可以检查函数和类、类型检查</p>
<ul>
<li>inspect.isfunction(add) ,  是否是函数</li>
<li>inspect.ismethod(add) ,  是否是类的方法</li>
<li>inspect.isgenerator(add) , 是否是生成器对象</li>
<li>inspect.isgeneratorfunction(add) ,  是否是生成器函数</li>
<li>inspect.isclass(add) ， 是否是类</li>
<li>inspect.ismodule(inspect)  , 是否是模块</li>
<li>inspect.isbuiltin(print) ,  是否是内建对象</li>
</ul>
<p>signature(callable)，获取签名（函数签名包含了一个函数的信息，包括函数名，它的参数类型，它的所在的类和名称空间及其他信息）</p>
<p>Parameter对象</p>
<p>保存在元组中</p>
<p>输入属性：inspect.signature.parameters.annotation/name/kind/default</p>
<p>返回属性：inspect.signature.return_annotation</p>
<p>当不知道该方法下面有多少属性的时候，可以先用type查看该它的类型，然后通过导入模块，使用参数注解的方式来查看。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://vampireqian.github.io/2017/08/21/08python%E5%87%BD%E6%95%B0%E3%80%81%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E3%80%81%E8%A3%85%E9%A5%B0%E5%99%A8%E3%80%81%E5%8F%82%E6%95%B0%E6%B3%A8%E8%A7%A3%E3%80%81%E7%BC%93%E5%AD%98/" data-id="ckxlw2jbf000g0zex59uza8ml" data-title="python-函数、高阶函数、装饰器、参数注解" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/" rel="tag">python</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-07python标准库、解析式、生成器" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2017/08/15/07python%E6%A0%87%E5%87%86%E5%BA%93%E3%80%81%E8%A7%A3%E6%9E%90%E5%BC%8F%E3%80%81%E7%94%9F%E6%88%90%E5%99%A8/" class="article-date">
  <time class="dt-published" datetime="2017-08-14T16:00:00.000Z" itemprop="datePublished">2017-08-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/python/">python</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2017/08/15/07python%E6%A0%87%E5%87%86%E5%BA%93%E3%80%81%E8%A7%A3%E6%9E%90%E5%BC%8F%E3%80%81%E7%94%9F%E6%88%90%E5%99%A8/">python-标准库、解析式、生成器</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h3><h4 id="datetime模块"><a href="#datetime模块" class="headerlink" title="datetime模块"></a>datetime模块</h4><ul>
<li><p>对日期、时间、时间戳的处理</p>
</li>
<li><p>datetime类</p>
<ul>
<li><p>类方法：</p>
<ul>
<li><p> today():返回本地时区当前时间的datetime对象</p>
</li>
<li><p> now(tz=None)：返回当前时间的datetime对象，时间到微秒，如果tz为None，返回和today()一样</p>
</li>
<li><p> utcnow()：没有时区的当前时间（国际化的时候建议用这个）</p>
</li>
<li><p> fromtimestamp(timestamp , tz = None) 从一个时间戳返回一个datetime对象</p>
</li>
</ul>
</li>
<li><p>datetime对象</p>
<ul>
<li>timestamp()：返回一个到微秒的时间戳<ul>
<li>时间戳：格林威治时间1970年1月1日0点到现在的秒数。</li>
</ul>
</li>
<li>构造方法 datetime.datetime(2016, 12, 6, 16, 29, 43, 79043)</li>
<li>year、month、day、hour、minute、second、microsecond，取datetime对象的年月日时分秒及微秒</li>
<li>weekday() 返回星期的天，周一0，周日6</li>
<li>isoweekday() 返回星期的天，周一1，周日7</li>
<li>date() 返回日期date对象</li>
<li>time() 返回时间time对象</li>
<li>replace() 修改并返回新的时间</li>
<li>isocalendar() 返回一个三元组(年，周数，周的天)</li>
</ul>
</li>
<li><p><strong>日期格式化</strong></p>
<ul>
<li><p>类方法 strptime(date_string, format) ，返回datetime对象</p>
</li>
<li><p>对象方法 strftime(format) ，返回字符串</p>
</li>
<li><p>字符串format函数格式化</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line">dt = datetime.datetime.strptime(<span class="string">&quot;21/11/06 16:30&quot;</span>, <span class="string">&quot;%d/%m/%y %H:%M&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(dt.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#123;0:%Y&#125;/&#123;0:%m&#125;/&#123;0:%d&#125; &#123;0:%H&#125;::&#123;0:%M&#125;::&#123;0:%S&#125;&quot;</span>.<span class="built_in">format</span>(dt))</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>timedelta对象</p>
<ul>
<li><p>datetime2 = datetime1 + timedelta</p>
</li>
<li><p>datetime2 = datetime1 - timedelta</p>
</li>
<li><p>timedelta = datetime1 - datetime2</p>
</li>
<li><p>构造方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- datetime.timedelta(days=<span class="number">0</span>, seconds=<span class="number">0</span>, microseconds=<span class="number">0</span>, milliseconds=<span class="number">0</span>, </span><br><span class="line">minutes=<span class="number">0</span>, hours=<span class="number">0</span>, weeks=<span class="number">0</span>) </span><br><span class="line">- year = datetime.timedelta(days=<span class="number">365</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>total_seconds() 返回时间差的总秒数</p>
</li>
</ul>
</li>
</ul>
<h4 id="time模块"><a href="#time模块" class="headerlink" title="time模块"></a>time模块</h4><ul>
<li>time.sleep(secs) 将调用线程挂起指定的秒数（发起一个系统调用，让程序暂停）</li>
</ul>
<h3 id="解析式"><a href="#解析式" class="headerlink" title="解析式"></a>解析式</h3><h4 id="列表解析式"><a href="#列表解析式" class="headerlink" title="列表解析式"></a>列表解析式</h4><ol>
<li>语法:</li>
</ol>
<ul>
<li><p>[返回值   for   元素   in   可迭代对象   if   条件]</p>
</li>
<li><p>使用中括号[]，内部是for循环，if条件语句可选</p>
</li>
<li><p>返回一个新的列表</p>
</li>
</ul>
<ol start="2">
<li>列表解析式是一种语法糖：</li>
</ol>
<ul>
<li>编译器会优化，不会因为简写而影响效率，反而会因优化而提高了效率。</li>
<li>减少了程序员工作量，减少出错。</li>
<li>简化了代码，但可读性增强，不便于可读。</li>
</ul>
<ol start="3">
<li>举例：</li>
</ol>
<ul>
<li>获取10以内的偶数<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#普通</span></span><br><span class="line">even = []</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">  <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">    even.append(x)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#解析式</span></span><br><span class="line">even = [x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>) <span class="keyword">if</span> x%<span class="number">2</span> == <span class="number">0</span>]</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="4">
<li>思考:</li>
</ol>
<ul>
<li><p>有这样的赋值语句 <code>newlist = [print(i) for i in range(10)]</code>打印出来的是什么？<br>print()把所有的i全打印出来，newlist里面则是10个None</p>
</li>
<li><p>获取20以内的偶数，如果同时是3的倍数，把它打印出来</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>) <span class="keyword">if</span> <span class="keyword">not</span> i % <span class="number">2</span> <span class="keyword">and</span> i % <span class="number">3</span> == <span class="number">0</span>]</span><br><span class="line">[i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>) <span class="keyword">if</span> <span class="keyword">not</span> i % <span class="number">2</span> <span class="keyword">if</span> i % <span class="number">3</span> == <span class="number">0</span>]</span><br></pre></td></tr></table></figure></li>
<li><p>获取20以内2的倍数或者3的倍数，把它打印出来<br><code>[i for i in range(20) if not i % 2 or i % 3 == 0]</code></p>
</li>
<li><p>“0001.abadicddws” 是ID格式，要求ID格式是以点号分割，左边是4位从1开始的整数，右边是<br>10位随机小写英文字母。请依次生成前100个ID的列表</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">x= string.ascii_lowercase</span><br><span class="line">[<span class="string">&quot;&#123;:&gt;04&#125;.&#123;&#125;&quot;</span>.<span class="built_in">format</span>(i,<span class="string">&quot;&quot;</span>.join(random.choices(x,k = <span class="number">10</span>))) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">8</span>)]</span><br><span class="line"></span><br><span class="line">[<span class="string">&#x27;0001.rvverptnre&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;0002.beqkpbxhfl&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;0003.woxvvayzjo&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;0004.wrbnnkelcc&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;0005.kpsjowcfvz&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;0006.pnqwqzlttc&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;0007.wehobydqnf&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h4 id="字典解析式"><a href="#字典解析式" class="headerlink" title="字典解析式"></a>字典解析式</h4><ol>
<li>语法：</li>
</ol>
<ul>
<li>{返回值 for 元素 in 可迭代对象 if 条件}</li>
<li>列表解析式的中括号换成大括号{}就行了</li>
<li>使用key:value形式</li>
<li>立即返回一个字典<br>用法：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;x:(x,x+<span class="number">1</span>) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)&#125;</span><br><span class="line">&#123;x:[x,x+<span class="number">1</span>] <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)&#125;</span><br><span class="line">&#123;(x,):[x,x+<span class="number">1</span>] <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)&#125;</span><br><span class="line">&#123;[x]:[x,x+<span class="number">1</span>] <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)&#125; <span class="comment">#[x]不可哈希，字典的k要求可哈希</span></span><br><span class="line">&#123;<span class="built_in">chr</span>(<span class="number">0x41</span>+x):x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)&#125;</span><br><span class="line">&#123;<span class="built_in">str</span>(x):y <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>) <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)&#125; <span class="comment"># 输出多少个元素？</span></span><br><span class="line"><span class="comment">#会覆盖，返回&#123;0：3，1：3，2：3&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="集合解析式"><a href="#集合解析式" class="headerlink" title="集合解析式"></a>集合解析式</h4><ol>
<li>语法</li>
</ol>
<ul>
<li>{返回值 for 元素 in 可迭代对象 if 条件}</li>
<li>列表解析式的中括号换成大括号{}就行了</li>
<li>立即返回一个集合<br>用法<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;(x,x+<span class="number">1</span>) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)&#125;</span><br><span class="line">&#123;[x] <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)&#125; <span class="comment">#[x]是个集合，不能哈希，所以放在集合解析式里面会报错</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h4><h5 id="生成器Generator"><a href="#生成器Generator" class="headerlink" title="生成器Generator"></a>生成器Generator</h5><p>生成器指的是生成器对象，可以由生成器表达式得到，也可以使用yield关键字得到一个生成器函数，调用这个函数得到一个生成器对象。</p>
<p>生成器函数：</p>
<ol>
<li><p>函数体内包含yield语句的函数，返回一个生成器对象，生成器函数的函数体不会立即执行。</p>
<p> 生成器对象，是一个可迭代对象，是一个迭代器。</p>
</li>
<li><p>生成器对象，是延迟计算，惰性求值。</p>
</li>
<li><p>next(generator)会从函数的当前位置向后执行到之后碰到的第一个yield语句，会弹出值，并暂停函数执行。</p>
</li>
<li><p>再次执行会执行到下一个yield语句，没有多余的yield语句能执行，如果函数没有显式的return语句，继续调用next函数就会抛出StopIteration异常。</p>
</li>
<li><p>return会导致无法继续获取下一个值，抛出StopIteration异常。</p>
</li>
<li><p>生成器函数，它是函数，不过这个函数不像普通的函数调用时能返回一个合法的值，它返回的是一个还没有求过任何值的生成器对象，用next拨一下才会往后执行一下。</p>
</li>
<li><p>生成器提供了一个send方法，该方法可以和生成器方向沟通。调用send方法，就可以把send的实参传递给yield语句做结果，这个结果可以在等式右边被赋值给其他变量。yield和next一样可以推动生成器启动并执行。</p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#举例</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;line 1&#x27;</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;line 2&#x27;</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;line 3&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line"><span class="built_in">next</span>(gen()) <span class="comment"># line 1</span></span><br><span class="line"><span class="built_in">next</span>(gen()) <span class="comment"># line 1</span></span><br><span class="line">g = gen()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(g)) <span class="comment"># line 1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(g)) <span class="comment"># line 2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(g, <span class="string">&#x27;End&#x27;</span>)) <span class="comment"># 没有元素给个缺省值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(g, <span class="string">&#x27;End&#x27;</span>)) <span class="comment"># 没有元素给个缺省值</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>生成器的应用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#计数器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inc</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">counter</span>():</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">yield</span> i</span><br><span class="line">    c = counter()</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> : <span class="built_in">next</span>(c)</span><br><span class="line"></span><br><span class="line">foo = inc()</span><br><span class="line"><span class="built_in">print</span>(foo())   <span class="comment">#调用的时候是因为inc()函数返回的是一个匿名函数，而匿名函数的调用方式是（lambda 参数列表：函数体)(),所以调用的时候是foo后要加上（），即也就是inc()()。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#等价于</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inc</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">counter</span>():</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">yield</span> i</span><br><span class="line">    c = counter()</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_inc</span>():</span>  <span class="comment">#用到外面的自由变量（c）：闭包</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">next</span>(c)</span><br><span class="line">    <span class="keyword">return</span> _inc</span><br><span class="line">foo = inc()	   <span class="comment">#可调用对象，函数</span></span><br><span class="line"><span class="built_in">print</span>(foo())</span><br></pre></td></tr></table></figure>

<h5 id="yield-from"><a href="#yield-from" class="headerlink" title="yield from"></a>yield from</h5><p>yield from是python3.3出现的新语法</p>
<p>yield from iterable 是for item in iterable： yield item形式的语法糖。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">    <span class="keyword">yield</span> x</span><br><span class="line">    </span><br><span class="line"><span class="comment">#等价于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">yield</span> <span class="keyword">from</span> <span class="built_in">range</span>(<span class="number">1000</span>)</span><br></pre></td></tr></table></figure>

<p>从可迭代对象中一个个拿数据</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">counter</span>(<span class="params">n</span>):</span>   <span class="comment">#生成器，迭代器</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">yield</span> x</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inc</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> counter(n)</span><br><span class="line">    </span><br><span class="line">foo = inc(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(foo))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(foo))</span><br></pre></td></tr></table></figure>

<h5 id="协程coroutine"><a href="#协程coroutine" class="headerlink" title="协程coroutine"></a>协程coroutine</h5><p> 生成器的高级用法<br> 比进程、线程轻量级<br> 是在用户空间调度函数的一种实现<br> Python3 asyncio就是协程实现，已经加入到标准库<br> Python3.5 使用async、await关键字直接原生支持协程<br> 协程调度器实现思路</p>
<ul>
<li>有2个生成器A、B</li>
<li>next(A)后，A执行到了yield语句暂停，然后去执行next(B)，B执行到yield语句也暂停，然后再次调用next(A)，再调用next(B)在，周而复始，就实现了调度的效果</li>
<li>可以引入调度的策略来实现切换的方式</li>
</ul>
<p> 协程是一种非抢占式调度</p>
<h5 id="生成器表达式Generator-expression"><a href="#生成器表达式Generator-expression" class="headerlink" title="生成器表达式Generator expression"></a>生成器表达式Generator expression</h5><ol>
<li>语法</li>
</ol>
<ul>
<li><p>(返回值 for 元素 in 可迭代对象 if 条件)</p>
</li>
<li><p>列表解析式的中括号换成小括号就行了</p>
</li>
<li><p>返回一个生成器</p>
</li>
</ul>
<ol start="2">
<li>和列表解析式的区别</li>
</ol>
<ul>
<li><p>生成器表达式是按需计算（或称惰性求值、延迟计算），需要的时候才计算值，返回迭代器，可以迭代，从前到后走完一遍后，不能回头。</p>
</li>
<li><p>列表解析式是立即返回值，返回的不是迭代器，返回可迭代对象列表， 从前到后走完一遍后，可以重新回头迭代。</p>
</li>
</ul>
<ol start="3">
<li>和列表解析式的对比</li>
</ol>
<ul>
<li>计算方式<ul>
<li>生成器表达式延迟计算，列表解析式立即计算</li>
</ul>
</li>
<li>内存占用<ul>
<li>单从返回值本身来说，生成器表达式省内存，列表解析式返回新的列表</li>
<li>生成器没有数据，内存占用极少，但是使用的时候，虽然一个个返回数据，但是合起来占用的内存也差不多</li>
<li>列表解析式构造新的列表需要占用内存</li>
</ul>
</li>
<li>计算速度<ul>
<li>单看计算时间看，生成器表达式耗时非常短，列表解析式耗时长</li>
<li>但是生成器本身并没有返回任何值，只返回了一个生成器对象</li>
<li>列表解析式构造并返回了一个新的列表</li>
</ul>
</li>
</ul>
<ol start="4">
<li>生成器</li>
</ol>
<ul>
<li>可迭代对象(able结尾)</li>
<li>迭代器(or结尾)，是不是迭代器用next（）方法可以检测，iter（）方法可以把一个可迭代对象封装成迭代器。</li>
<li>生成器和迭代器是不同的对象，但都是可迭代对象，生成器对象，就是迭代器对象，迭代器不一定是生成器。</li>
</ul>
<h4 id="内建函数"><a href="#内建函数" class="headerlink" title="内建函数"></a>内建函数</h4><ol>
<li>标识 id </li>
</ol>
<ul>
<li>返回对象的唯一标识，CPython返回内存地址</li>
</ul>
<ol start="2">
<li>哈希 hash() </li>
</ol>
<ul>
<li>返回一个对象的哈希值</li>
</ul>
<ol start="3">
<li>类型 type() </li>
</ol>
<ul>
<li>返回对象的类型</li>
</ul>
<ol start="4">
<li>类型转换</li>
</ol>
<ul>
<li>float() int() bin() hex() oct() bool() list() tuple() dict() set() complex() bytes() bytearray() </li>
</ul>
<ol start="5">
<li>输入 input([prompt]) </li>
</ol>
<ul>
<li>接收用户输入，返回一个字符串</li>
</ul>
<ol start="6">
<li>打印 print(*objects, sep=’ ‘, end=’\n’, file=sys.stdout, flush=False)</li>
</ol>
<ul>
<li>打印输出，默认使用空格分割、换行结尾，输出到控制台</li>
</ul>
<ol start="7">
<li>对象长度 len(s)</li>
</ol>
<ul>
<li>返回一个集合类型的元素个数</li>
</ul>
<ol start="8">
<li>isinstance(obj, class_or_tuple) </li>
</ol>
<ul>
<li>判断对象obj是否属于某种类型或者元组中列出的某个类型</li>
<li>isinstance(True, int)</li>
</ul>
<ol start="9">
<li>issubclass(cls, class_or_tuple)</li>
</ol>
<ul>
<li>判断类型cls是否是某种类型的子类或元组中列出的某个类型的子类</li>
<li>issubclass(bool, int)</li>
</ul>
<ol start="10">
<li><p>绝对值abs(x)  x为数值</p>
</li>
<li><p>最大值max() 最小值min() </p>
</li>
</ol>
<ul>
<li>返回可迭代对象中最大或最小值</li>
<li>返回多个参数中最大或最小值</li>
</ul>
<ol start="12">
<li><p>round(x) 四舍六入五取偶，round(-0.5)</p>
</li>
<li><p>pow(x , y) 等价于 x**y</p>
</li>
<li><p>range(stop) 从0开始到stop-1的可迭代对象；range(start, stop[, step])从start开始到stop-1结束步长为step的可迭代对象</p>
</li>
<li><p>divmod(x, y) 等价于 tuple (x//y, x%y)</p>
</li>
<li><p>sum(iterable[, start]) 对可迭代对象的所有数值元素求和，start：初始值</p>
</li>
</ol>
<ul>
<li>sum(range(1,100,2))</li>
</ul>
<ol start="17">
<li>chr(i) 给一个一定范围的整数返回对应的字符</li>
</ol>
<ul>
<li>chr(97)    chr(20013)</li>
</ul>
<ol start="18">
<li>ord(c) 返回字符对应的整数</li>
</ol>
<ul>
<li>ord(‘a’)    ord(‘中’)</li>
</ul>
<ol start="19">
<li>sorted<br>sorted(iterable[, key][, reverse] )排序</li>
</ol>
<ul>
<li>返回一个新的列表，对一个可迭代对象的所有元素进行排序，默认升序</li>
<li>reverse是反转<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sorted</span>([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>])</span><br><span class="line"><span class="built_in">sorted</span>([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>], reverse=<span class="literal">True</span>)   <span class="comment">#[5， 3 ， 1]</span></span><br><span class="line"><span class="built_in">sorted</span>(&#123;<span class="string">&#x27;c&#x27;</span>:<span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>:<span class="number">2</span>, <span class="string">&#x27;a&#x27;</span>:<span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="20">
<li><p>翻转 reversed(seq)<br>返回一个翻转元素的迭代器(惰性求值)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>(<span class="built_in">reversed</span>(<span class="string">&quot;13579&quot;</span>))</span><br><span class="line">&#123; <span class="built_in">reversed</span>((<span class="number">2</span>, <span class="number">4</span>)) &#125; <span class="comment"># 有几个元素？</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">reversed</span>([<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;a&#x27;</span>]):</span><br><span class="line">	<span class="built_in">print</span>(x)</span><br><span class="line"><span class="built_in">reversed</span>(<span class="built_in">sorted</span>(&#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>&#125;))</span><br></pre></td></tr></table></figure></li>
<li><p>枚举 enumerate(seq, start=0)</p>
</li>
</ol>
<p>迭代一个序列，返回索引数字和元素构成的二元组<br>start表示索引开始的数字，默认是0</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">enumerate</span>([<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>]):</span><br><span class="line">	<span class="built_in">print</span>(x)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="string">&quot;abcde&quot;</span>):</span><br><span class="line">	<span class="built_in">print</span>(x,end=<span class="string">&quot; &quot;</span>)</span><br></pre></td></tr></table></figure>
<ol start="22">
<li>迭代器和取元素 iter(iterable)、next(iterator[, default])</li>
</ol>
<p>iter将一个可迭代对象封装成一个迭代器<br>next对一个迭代器取下一个元素。如果全部元素都取过了，再次next会抛StopIteration异常</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">it = <span class="built_in">iter</span>(<span class="built_in">range</span>(<span class="number">5</span>))</span><br><span class="line"><span class="built_in">next</span>(it)</span><br><span class="line"></span><br><span class="line">it = <span class="built_in">reversed</span>([<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>])</span><br><span class="line"><span class="built_in">next</span>(it)</span><br></pre></td></tr></table></figure>

<ol start="23">
<li><p>拉链函数zip(*iterables)<br>像拉链一样，把多个可迭代对象合并在一起，返回一个迭代器<br>将每次从不同对象中取到的元素合并成一个元组</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>(<span class="built_in">zip</span>(<span class="built_in">range</span>(<span class="number">10</span>),<span class="built_in">range</span>(<span class="number">10</span>)))</span><br><span class="line"><span class="built_in">list</span>(<span class="built_in">zip</span>(<span class="built_in">range</span>(<span class="number">10</span>),<span class="built_in">range</span>(<span class="number">10</span>),<span class="built_in">range</span>(<span class="number">5</span>),<span class="built_in">range</span>(<span class="number">10</span>)))</span><br><span class="line"></span><br><span class="line"><span class="built_in">dict</span>(<span class="built_in">zip</span>(<span class="built_in">range</span>(<span class="number">10</span>),<span class="built_in">range</span>(<span class="number">10</span>)))</span><br><span class="line">&#123;<span class="built_in">str</span>(x):y <span class="keyword">for</span> x,y <span class="keyword">in</span> <span class="built_in">zip</span>(<span class="built_in">range</span>(<span class="number">10</span>),<span class="built_in">range</span>(<span class="number">10</span>))&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>过滤数据filter(function, iterable) — &gt;filter object</p>
<p>过滤可迭代对象的元素，返回一个迭代器</p>
<p>function是一个具有一个参数的函数。返回bool</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#例子：过滤出数列中能被3整除的数字</span></span><br><span class="line">In [<span class="number">4</span>]: <span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x%<span class="number">3</span> == <span class="number">0</span>,[<span class="number">1</span>,<span class="number">9</span>,<span class="number">32</span>,<span class="number">3</span>,<span class="number">21</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">123</span>]))</span><br><span class="line">Out[<span class="number">4</span>]: [<span class="number">9</span>, <span class="number">3</span>, <span class="number">21</span>, <span class="number">0</span>, <span class="number">123</span>]</span><br></pre></td></tr></table></figure></li>
<li><p>reduce：连续计算，连续从一个可迭代对象中获取值，来进行计算，需要从functools模块中导入</p>
</li>
<li><p>映射map(func,  *iterables) —-&gt;    map object</p>
<p>对多个可迭代对象的元素按照指定的函数进行映射，返回一个迭代器</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://vampireqian.github.io/2017/08/15/07python%E6%A0%87%E5%87%86%E5%BA%93%E3%80%81%E8%A7%A3%E6%9E%90%E5%BC%8F%E3%80%81%E7%94%9F%E6%88%90%E5%99%A8/" data-id="ckxlw2jbd000a0zex9vtk2v31" data-title="python-标准库、解析式、生成器" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/" rel="tag">python</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; zurück</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">weiter &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Kategorien</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/">云计算</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9D%82%E9%A1%B9/">杂项</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9D%82%E9%A1%B9%E6%95%99%E7%A8%8B/">杂项教程</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/eclipse/" rel="tag">eclipse</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/excel/" rel="tag">excel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/" rel="tag">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/socket/" rel="tag">socket</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/windows/" rel="tag">windows</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%91%E8%AE%A1%E7%AE%97%EF%BC%8C%E9%98%BF%E9%87%8C%E4%BA%91/" rel="tag">云计算，阿里云</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8C%89%E4%BD%8D%E8%AE%A1%E7%AE%97/" rel="tag">按位计算</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/" rel="tag">日志分析</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Java/" style="font-size: 13.33px;">Java</a> <a href="/tags/Linux/" style="font-size: 16.67px;">Linux</a> <a href="/tags/eclipse/" style="font-size: 10px;">eclipse</a> <a href="/tags/excel/" style="font-size: 10px;">excel</a> <a href="/tags/python/" style="font-size: 20px;">python</a> <a href="/tags/socket/" style="font-size: 10px;">socket</a> <a href="/tags/windows/" style="font-size: 13.33px;">windows</a> <a href="/tags/%E4%BA%91%E8%AE%A1%E7%AE%97%EF%BC%8C%E9%98%BF%E9%87%8C%E4%BA%91/" style="font-size: 10px;">云计算，阿里云</a> <a href="/tags/%E6%8C%89%E4%BD%8D%E8%AE%A1%E7%AE%97/" style="font-size: 10px;">按位计算</a> <a href="/tags/%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/" style="font-size: 10px;">日志分析</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/01/01/%E9%98%BF%E9%87%8C%E4%BA%91%E5%B9%B3%E5%8F%B0%E4%BD%BF%E7%94%A8%E5%AE%89%E5%85%A8/">云计算使用简介</a>
          </li>
        
          <li>
            <a href="/2018/10/05/excel%E5%90%88%E5%B9%B6%E8%A1%A8%E6%A0%BC%E7%94%A8/">excel合并表格</a>
          </li>
        
          <li>
            <a href="/2018/08/02/win10win7%E6%89%93%E5%BC%80%E8%BD%AF%E4%BB%B6%E6%8F%90%E7%A4%BA%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90%E4%B8%8D%E8%B6%B3,%E6%97%A0%E6%B3%95%E5%AE%8C%E6%88%90%E8%AF%B7%E6%B1%82%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/">win10win7打开软件提示系统资源不足,无法完成请求服务的解决方法</a>
          </li>
        
          <li>
            <a href="/2018/07/25/centos6%E4%B8%8B%E9%83%A8%E7%BD%B2Java%20Web%E9%A1%B9%E7%9B%AE/">centos6下部署Java Web项目</a>
          </li>
        
          <li>
            <a href="/2018/07/25/%E5%9C%A8eclipse%E4%B8%AD%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AEweb%E6%9C%89%E6%97%B6%E5%80%99%E8%AE%BF%E9%97%AEjsp%E4%BC%9A%E6%8A%9B%E5%87%BA%E4%BB%A5%E4%B8%8B%E7%B1%BB%E4%BC%BC%E7%9A%84%E5%BC%82%E5%B8%B8%E4%BF%A1%E6%81%AF/">在eclipse中部署项目web有时候访问jsp会抛出以下类似的异常信息</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 luoqian<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>