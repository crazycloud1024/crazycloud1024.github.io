<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"vampireqian.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.8.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"بحث...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>
<meta name="description" content="并发并发和并行的区别并行、parallel ​    同时做某些事情，可以互不干扰的同一时刻做几件事 并发、concurrency ​    一个时段内有事情要处理。  并发的解决1、队列、缓冲区使用队列，先进先出，解决了资源使用的问题。排成的队列，其实就是一个缓冲地带，就是缓冲区。（队列的作用：解耦，缓冲） 2、争抢通过争抢，当一个抢到时就会触发一种类似锁机制，抢到资源就上锁，排他性的锁。这也是">
<meta property="og:type" content="article">
<meta property="og:title" content="python-并发和线程">
<meta property="og:url" content="https://vampireqian.github.io/2017/11/09/17%E5%B9%B6%E5%8F%91%E5%92%8C%E7%BA%BF%E7%A8%8B/index.html">
<meta property="og:site_name" content="luoqian">
<meta property="og:description" content="并发并发和并行的区别并行、parallel ​    同时做某些事情，可以互不干扰的同一时刻做几件事 并发、concurrency ​    一个时段内有事情要处理。  并发的解决1、队列、缓冲区使用队列，先进先出，解决了资源使用的问题。排成的队列，其实就是一个缓冲地带，就是缓冲区。（队列的作用：解耦，缓冲） 2、争抢通过争抢，当一个抢到时就会触发一种类似锁机制，抢到资源就上锁，排他性的锁。这也是">
<meta property="og:locale">
<meta property="article:published_time" content="2017-11-08T16:00:00.000Z">
<meta property="article:modified_time" content="2018-12-11T13:37:22.000Z">
<meta property="article:author" content="luoqian">
<meta property="article:tag" content="python">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://vampireqian.github.io/2017/11/09/17%E5%B9%B6%E5%8F%91%E5%92%8C%E7%BA%BF%E7%A8%8B/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh","comments":true,"permalink":"https://vampireqian.github.io/2017/11/09/17%E5%B9%B6%E5%8F%91%E5%92%8C%E7%BA%BF%E7%A8%8B/","path":"2017/11/09/17并发和线程/","title":"python-并发和线程"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>python-并发和线程 | luoqian</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="تشغيل شريط التصفح" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">luoqian</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          المحتويات
        </li>
        <li class="sidebar-nav-overview">
          عام
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91"><span class="nav-number">1.</span> <span class="nav-text">并发</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.</span> <span class="nav-text">并发和并行的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E7%9A%84%E8%A7%A3%E5%86%B3"><span class="nav-number">1.2.</span> <span class="nav-text">并发的解决</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E9%98%9F%E5%88%97%E3%80%81%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="nav-number">1.2.0.1.</span> <span class="nav-text">1、队列、缓冲区</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E4%BA%89%E6%8A%A2"><span class="nav-number">1.2.0.2.</span> <span class="nav-text">2、争抢</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E9%A2%84%E5%A4%84%E7%90%86"><span class="nav-number">1.2.0.3.</span> <span class="nav-text">3、预处理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81%E5%B9%B6%E8%A1%8C"><span class="nav-number">1.2.0.4.</span> <span class="nav-text">4、并行</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5%E3%80%81%E6%8F%90%E9%80%9F"><span class="nav-number">1.2.0.5.</span> <span class="nav-text">5、提速</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6%E3%80%81%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="nav-number">1.2.0.6.</span> <span class="nav-text">6、消息中间件</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.</span> <span class="nav-text">进程和线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="nav-number">2.1.</span> <span class="nav-text">线程的状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Python%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.2.</span> <span class="nav-text">Python中的进程和线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Python%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91"><span class="nav-number">2.3.</span> <span class="nav-text">Python的线程开发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Thread%E7%B1%BB"><span class="nav-number">2.4.</span> <span class="nav-text">Thread类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%AF%E5%8A%A8"><span class="nav-number">2.4.1.</span> <span class="nav-text">线程启动</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E9%80%80%E5%87%BA"><span class="nav-number">2.4.2.</span> <span class="nav-text">线程退出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#threading%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95"><span class="nav-number">2.4.3.</span> <span class="nav-text">threading的属性和方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Thread%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95"><span class="nav-number">2.4.4.</span> <span class="nav-text">Thread实例的属性和方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#start%E6%96%B9%E6%B3%95%E5%92%8Crun%E6%96%B9%E6%B3%95"><span class="nav-number">2.4.5.</span> <span class="nav-text">start方法和run方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.5.</span> <span class="nav-text">多线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-number">2.6.</span> <span class="nav-text">线程安全</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#daemon%E7%BA%BF%E7%A8%8B%E5%92%8Cnon-daemon%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.7.</span> <span class="nav-text">daemon线程和non-daemon线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#join%E6%96%B9%E6%B3%95"><span class="nav-number">2.8.</span> <span class="nav-text">join方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#daemon%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">2.9.</span> <span class="nav-text">daemon线程的应用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#threading-local%E7%B1%BB"><span class="nav-number">2.10.</span> <span class="nav-text">threading.local类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8Timer-%E5%BB%B6%E6%97%B6%E6%89%A7%E8%A1%8C"><span class="nav-number">2.11.</span> <span class="nav-text">定时器Timer&#x2F;延时执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="nav-number">2.12.</span> <span class="nav-text">线程同步</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Event%E4%BA%8B%E4%BB%B6"><span class="nav-number">2.12.1.</span> <span class="nav-text">Event事件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Lock"><span class="nav-number">2.12.2.</span> <span class="nav-text">Lock</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A0%E9%94%81%E5%92%8C%E8%A7%A3%E9%94%81"><span class="nav-number">2.12.3.</span> <span class="nav-text">加锁和解锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%81%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">2.12.4.</span> <span class="nav-text">锁的应用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81RLOCK"><span class="nav-number">2.12.5.</span> <span class="nav-text">可重入锁RLOCK</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Condition"><span class="nav-number">2.12.6.</span> <span class="nav-text">Condition</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">luoqian</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">26</span>
          <span class="site-state-item-name">المقالات</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">التصنيفات</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">الوسوم</span>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh">
    <link itemprop="mainEntityOfPage" href="https://vampireqian.github.io/2017/11/09/17%E5%B9%B6%E5%8F%91%E5%92%8C%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="luoqian">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="luoqian">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          python-并发和线程
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">نُشر في</span>

      <time title="أُنشأ: 2017-11-09 00:00:00" itemprop="dateCreated datePublished" datetime="2017-11-09T00:00:00+08:00">2017-11-09</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">عُدل في</span>
        <time title="عُدل: 2018-12-11 21:37:22" itemprop="dateModified" datetime="2018-12-11T21:37:22+08:00">2018-12-11</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">في</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><h3 id="并发和并行的区别"><a href="#并发和并行的区别" class="headerlink" title="并发和并行的区别"></a>并发和并行的区别</h3><p>并行、parallel</p>
<p>​    同时做某些事情，可以互不干扰的同一时刻做几件事</p>
<p>并发、concurrency</p>
<p>​    一个时段内有事情要处理。</p>
<hr>
<h3 id="并发的解决"><a href="#并发的解决" class="headerlink" title="并发的解决"></a>并发的解决</h3><h5 id="1、队列、缓冲区"><a href="#1、队列、缓冲区" class="headerlink" title="1、队列、缓冲区"></a>1、队列、缓冲区</h5><p>使用队列，先进先出，解决了资源使用的问题。排成的<strong>队列</strong>，其实就是一个缓冲地带，就是<strong>缓冲区</strong>。（队列的作用：解耦，缓冲）</p>
<h5 id="2、争抢"><a href="#2、争抢" class="headerlink" title="2、争抢"></a>2、争抢</h5><p>通过争抢，当一个抢到时就会触发一种类似<strong>锁机制</strong>，抢到资源就上锁，排他性的锁。这也是一种高并发解决方案，但是这样就有可能会有些会很长时间都抢不到。</p>
<h5 id="3、预处理"><a href="#3、预处理" class="headerlink" title="3、预处理"></a>3、预处理</h5><p>一种提前加载用户需要的数据的思路，预处理思想，缓存常用。（要考虑到冷、热数据的问题，经常访问的数据可以先预加载）</p>
<h5 id="4、并行"><a href="#4、并行" class="headerlink" title="4、并行"></a>4、并行</h5><p>一般日常可以通过购买服务器，或多开进程、线程实现并行处理，来解决并发问题。注意：这些都是<strong>水平拓展</strong>的思想。</p>
<p>注：<br>如果线程在单CPU上处理，就不是并行了。<br>但是多数服务器都是多CPU的，服务的部署往往是多机的、分布式的，这都是并行处理。</p>
<h5 id="5、提速"><a href="#5、提速" class="headerlink" title="5、提速"></a>5、提速</h5><p>提高单个CPU性能，或单个服务器安装更多的CPU。<br>这是一种<strong>垂直扩展</strong>思想。</p>
<h5 id="6、消息中间件"><a href="#6、消息中间件" class="headerlink" title="6、消息中间件"></a>6、消息中间件</h5><p>一般就是在程序之前实现的技术。</p>
<p>常见的消息中间件有RabbitMQ、ActiveMQ（Apache）、RocketMQ（阿里Apache）、kafka（Apache）等</p>
<p>总结：一般来说不同的并发场景使用不同的策略，而策略可能是多种方式的优化组合。</p>
<hr>
<h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><p>在实现了线程的操作系统中，<strong>线程</strong>是操作系统能够进行<strong>运算调度</strong>的最小单位。它被包含在进程之中，是进程中的实际运作单位。一个程序的执行实例就是一个进程。<br><strong>进程</strong>（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行<strong>资源分配和调度</strong>的基本单位，是操作系统结构的基础。</p>
<p>进程和程序的关系<br>程序是源代码编译后的文件，而这些文件存放在磁盘上。当程序被操作系统加载到内存中，就是进程，进程中存放着指令和数据（资源），它也是线程的容器。</p>
<p>Linux进程有父进程、子进程，Windows的进程是平等关系。</p>
<p>线程，有时被称为轻量级进程(Lightweight Process，LWP），是程序执行流的最小单元。<br>一个标准的线程由线程ID，当前指令指针(PC），寄存器集合和堆栈组成。<br>在许多系统中，创建一个线程比创建一个进程快10-100倍。</p>
<p>进程、线程的理解<br>现代操作系统提出进程的概念，每一个进程都认为自己独占所有的计算机硬件资源。<br>进程就是独立的王国，进程间不可以随便的共享数据。<br>线程就是省份，同一个进程内的线程可以共享进程的资源，每一个线程拥有自己独立的<strong>堆栈</strong>。</p>
<h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><table>
<thead>
<tr>
<th>状态</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>就绪(Ready)</td>
<td>线程能够运行，但在等待被调度。可能线程刚刚创建启动，或刚刚从阻塞中恢复，或者被其他线程抢占</td>
</tr>
<tr>
<td>运行(Running)</td>
<td>线程正在运行</td>
</tr>
<tr>
<td>阻塞(Blocked)</td>
<td>线程等待外部事件发生而无法运行，如I/O操作</td>
</tr>
<tr>
<td>终止(Terminated)</td>
<td>线程完成，或退出，或被取消</td>
</tr>
</tbody></table>
<h3 id="Python中的进程和线程"><a href="#Python中的进程和线程" class="headerlink" title="Python中的进程和线程"></a>Python中的进程和线程</h3><hr>
<p>进程会启动一个解释器进程，线程共享一个解释器进程</p>
<h3 id="Python的线程开发"><a href="#Python的线程开发" class="headerlink" title="Python的线程开发"></a>Python的线程开发</h3><hr>
<p>Python的线程开发使用标准库threading</p>
<h3 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#签名</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, group=<span class="literal">None</span>, target=<span class="literal">None</span>, name=<span class="literal">None</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                 args=(<span class="params"></span>), kwargs=<span class="literal">None</span>, *, daemon=<span class="literal">None</span></span>):</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数名</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>target</td>
<td>线程调用的对象，就是目标函数</td>
</tr>
<tr>
<td>name</td>
<td>为线程起的名字</td>
</tr>
<tr>
<td>args</td>
<td>为目标函数传递实参，元组</td>
</tr>
<tr>
<td>kwargs</td>
<td>为目标函数关键字传参，字典</td>
</tr>
</tbody></table>
<h4 id="线程启动"><a href="#线程启动" class="headerlink" title="线程启动"></a>线程启动</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 最简单的线程程序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;I&#x27;m working&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Fineshed&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">t = threading.Thread(target=worker, name=<span class="string">&#x27;worker&#x27;</span>) <span class="comment"># 线程对象</span></span><br><span class="line">t.start() <span class="comment">#  启动</span></span><br></pre></td></tr></table></figure>

<p>通过threading.Thread创建一个线程对象，target是目标函数，name可以指定名称。<br>但是线程没有启动，需要调用start方法。<br>线程之所以执行函数，是因为线程中就是执行代码的，而最简单的封装就是函数，所以其实还是函数调用，当函数执行完，线程就退出，当主线程结束后，程序也就执行完毕。</p>
<h4 id="线程退出"><a href="#线程退出" class="headerlink" title="线程退出"></a>线程退出</h4><p>Python没有提供线程退出的方法，线程在下面情况时退出。</p>
<p>1、线程函数内语句执行完毕<br>2、线程函数中抛出未处理的异常</p>
<p>Python的线程没有优先级，没有线程组的概念，也不能被销毁、停止、挂起、那也没有恢复、中断了。</p>
<h4 id="threading的属性和方法"><a href="#threading的属性和方法" class="headerlink" title="threading的属性和方法"></a>threading的属性和方法</h4><table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>current_thread()</td>
<td>返回当前线程对象</td>
</tr>
<tr>
<td>main_thread()</td>
<td>返回主线程对象</td>
</tr>
<tr>
<td>active_count()</td>
<td>当前处于alive状态的线程个数</td>
</tr>
<tr>
<td>enumerate()</td>
<td>返回所有活着的线程的列表，不包括已经终止的线程和未开始的线程</td>
</tr>
<tr>
<td>get_ident()</td>
<td>返回当前线程的ID,非0整数</td>
</tr>
</tbody></table>
<p>active_count、enumerate方法返回的值还包括主线程。</p>
<h4 id="Thread实例的属性和方法"><a href="#Thread实例的属性和方法" class="headerlink" title="Thread实例的属性和方法"></a>Thread实例的属性和方法</h4><table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>name</td>
<td>只是一个名字，只是一个标识，名称可以重名。getName(),setName()，获取设置这个名词</td>
</tr>
<tr>
<td>ident</td>
<td>线程ID，它是非0整数。线程启动后才会有ID，否则为None。线程退出，此ID依旧可以访问。此ID可以重复使用</td>
</tr>
<tr>
<td>is_alive()</td>
<td>返回线程是否活着</td>
</tr>
</tbody></table>
<p>注意：线程的name这是一个名称，可以重复；ID必须唯一，但可以在线程退出后再利用。</p>
<h4 id="start方法和run方法"><a href="#start方法和run方法" class="headerlink" title="start方法和run方法"></a>start方法和run方法</h4><table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>start()</td>
<td>启动线程。每一个线程必须且只能执行该方法一次</td>
</tr>
<tr>
<td>run()</td>
<td>运行线程函数</td>
</tr>
</tbody></table>
<p>虽然说，start()方法会调用run()方法，而run()方法可以运行函数。<br>但是在使用start()方法启动线程，是启动了一个新的线程，而使用run方法只是在主线程中调用了一个普通的函数而已，并没有启动新的线程。</p>
<hr>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>一个进程中如果有多个线程，就是多线程，实现一种并发。</p>
<p>当使用start方法启动线程后，进程内有多个活动的线程并行的工作，就是多线程。</p>
<p>一个进程中至少有一个线程，并作为程序的入口，这个线程就是主线程。一个进程至少有一个主线程。<br>其他线程称为工作线程。</p>
<hr>
<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>线程安全，就是线程执行一段代码，不会产生不确定的结果，那这段代码就是线程安全的。</p>
<p>当在线程中使用print函数的时候，可以让它不打印换行，这样就可以避免print函数线程不安全；还可以使用标准库中的logging模块，日志处理模块，线程安全的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span>():</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">        logging.warning(<span class="string">&quot;&#123;&#125; is running&quot;</span>.<span class="built_in">format</span>(threading.current_thread().name))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">5</span>):</span><br><span class="line">    name = <span class="string">&quot;worker-&#123;&#125;&quot;</span>.<span class="built_in">format</span>(x)</span><br><span class="line">    t = threading.Thread(target=worker, name=name)</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="daemon线程和non-daemon线程"><a href="#daemon线程和non-daemon线程" class="headerlink" title="daemon线程和non-daemon线程"></a>daemon线程和non-daemon线程</h3><p>进程靠线程执行代码，至少有一个主线程，其它线程是工作线程。</p>
<p>主线程是第一个启动的线程。</p>
<p>父线程：如果线程A中启动了一个线程B，A就是B的父线程。</p>
<p>子线程：B就是A的子线程。</p>
<p>python中，构造线程的时候，可以设置daemon属性，这个属性必须在start方法前设置好。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 源码Thread的__init__方法中</span></span><br><span class="line"><span class="keyword">if</span> daemon <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">	self._daemonic = daemon <span class="comment"># 用户设定bool值</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	self._daemonic = current_thread().daemon</span><br><span class="line">self._ident = <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<p>线程daemon属性，如果设定就是用户的设置，否则就取当前线程的daemon值。<br>主线程是non-daemon线程，即daemon = False。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>daemon属性</td>
<td>表示线程是否是daemon线程，这个值必须在start()之前设置，否则引发RuntimeError异常</td>
</tr>
<tr>
<td>isDaemon()</td>
<td>是否是daemon线程</td>
</tr>
<tr>
<td>setDaemon</td>
<td>设置为daemon线程，必须在start方法之前设置</td>
</tr>
</tbody></table>
<p>总结：线程具有daemon属性，可以显示设置为True或False，也可以不设置，则取默认值None<br>如果不设置daemon，就取当前线程的daemon来设置它。</p>
<p>主线程是non-daemon线程，即daemon = False。<br>从主线程创建的所有线程的不设置daemon属性，则默认都是daemon = False，也就是non-daemon线程。</p>
<p>Python程序在没有活着的non-daemon线程运行时退出，也就是剩下的只能是daemon线程，主线程才能退出，否则主线程就只能等待。</p>
<p>如果有non-daemon线程的时候，主线程退出时，也不会杀掉所有daemon线程，直到所有non-daemon线程全部结束，如果还有daemon线程，主线程需要退出，会结束所有daemon线程，退出。</p>
<hr>
<h3 id="join方法"><a href="#join方法" class="headerlink" title="join方法"></a>join方法</h3><p>join(timeout=None)，是线程的标准方法之一。<br>一个线程中调用另一个线程的join方法，调用者将被阻塞，直到被调用线程终止。<br>一个线程可以被join多次。<br>timeout参数指定调用者等待多久，没有设置超时，就一直等到被调用线程结束。<br>一个线程调用谁的join方法，就是join谁，就要等谁。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="built_in">print</span>(i)</span><br><span class="line">        time.sleep(<span class="number">0.3</span>)</span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target=foo, args=(<span class="number">10</span>,), daemon=<span class="literal">True</span>)</span><br><span class="line">t1.start()</span><br><span class="line">t1.join()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Main Thread Exiting&quot;</span>)					</span><br></pre></td></tr></table></figure>

<p>使用了join方法后，daemon线程执行完了，主线程才退出。</p>
<hr>
<h3 id="daemon线程的应用场景"><a href="#daemon线程的应用场景" class="headerlink" title="daemon线程的应用场景"></a>daemon线程的应用场景</h3><p>这个概念唯一的作用就是，当你把一个线程设置为 daemon，它会随主线程的退出而退出。</p>
<p>主要应用场景有：</p>
<p>1、后台任务。如发送心跳包、监控，这种场景最多。</p>
<p>2、主线程工作才有用的线程。如主线程中维护这公共的资源，主线程已经清理了，准备退出，而工作线程使用这些资源工作也没有意义了，一起退出最合适。</p>
<p>3、随时可以被终止的线程</p>
<p>如果主线程退出，想所有其它工作线程一起退出，就使用daemon=True来创建工作线程。</p>
<p>比如，开启一个线程定时判断WEB服务是否正常工作，主线程退出，工作线程也没有必须存在了，应该随着主线程退出一起退出。这种daemon线程一旦创建，就可以忘记它了，只用关心主线程什么时候退出就行了。<br>daemon线程，简化了程序员手动关闭线程的工作。</p>
<p>如果在non-daemon线程A中，对另一个daemon线程B使用了join方法，这个线程B设置成daemon就没有什么意义了，因为non-daemon线程A总是要等待B。</p>
<p>如果在一个daemon线程C中，对另一个daemon线程D使用了join方法，只能说明C要等待D，主线程退出，C和D不管是否结束，也不管它们谁等谁，都要被杀掉。</p>
<hr>
<h3 id="threading-local类"><a href="#threading-local类" class="headerlink" title="threading.local类"></a>threading.local类</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment"># 局部变量实现</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span>():</span></span><br><span class="line">    x = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    	time.sleep(<span class="number">0.0001</span>)</span><br><span class="line">   		x += <span class="number">1</span></span><br><span class="line">	<span class="built_in">print</span>(threading.current_thread(), x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">	threading.Thread(target=worker).start()</span><br></pre></td></tr></table></figure>

<p>当想保证线程安全，可以使用局部变量来进行运算，避免错误。</p>
<p>当然如果想使用全局变量，那就可以使用threading下的local类，将这个类实例化得到一个全局变量，但是不同的线程使用这个对象存储的数据，其他线程看不见。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">global_date = threading.local()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span>():</span></span><br><span class="line">    global_date.x = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">        time.sleep(<span class="number">0.001</span>)</span><br><span class="line">        global_date.x += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(threading.current_thread(), global_date.x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    threading.Thread(target=worker).start()</span><br><span class="line">    </span><br><span class="line"><span class="comment">#&lt;Thread(Thread-3, started 3648)&gt; 100</span></span><br><span class="line"><span class="comment">#&lt;Thread(Thread-4, started 9404)&gt; 100</span></span><br><span class="line"><span class="comment">#&lt;Thread(Thread-1, started 7472)&gt; 100</span></span><br><span class="line"><span class="comment">#&lt;Thread(Thread-5, started 10876)&gt; 100</span></span><br><span class="line"><span class="comment">#&lt;Thread(Thread-2, started 12424)&gt; 100</span></span><br></pre></td></tr></table></figure>
<p>threading.local类构建了一个大字典，存放所有线程相关的字典，定义如下：<br>{ id(thread) -&gt;  (ref(thread), thread-local dict)  }<br>每一线程实例的id为key，元组为value。value中两部分为线程对象引用，每个线程自己的字典。</p>
<blockquote>
<p>本质<br>运行时，threading.local实例处在不同的线程中，就从大字典中找到当前线程相关键值对中的字典，覆盖threading.local实例的 __dict__ 。<br>这样就可以在不同的线程中，安全地使用线程独有的数据，做到了线程间数据隔离，如同本地变量一样安全</p>
</blockquote>
<h3 id="定时器Timer-延时执行"><a href="#定时器Timer-延时执行" class="headerlink" title="定时器Timer/延时执行"></a>定时器Timer/延时执行</h3><hr>
<p>threading.Timer继承自Thread，这个类用来定义延迟多久后执行一个函数。</p>
<p>class.threading.Timer(interval, function, args=None, kwargs=None)<br>start方法执行之后，Timer对象会处于等待状态，等待了interval秒之后，然后开始执行function函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">FORMAT = <span class="string">&quot;%(asctime)s %(threadName)s %(thread)d  %(message)s&quot;</span></span><br><span class="line">logging.basicConfig(level=logging.INFO, <span class="built_in">format</span>=FORMAT)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span>():</span></span><br><span class="line">    logging.info(<span class="string">&quot;in worker&quot;</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t = threading.Timer(<span class="number">4</span>, worker)</span><br><span class="line">t.setName(<span class="string">&quot;timer&quot;</span>)</span><br><span class="line"></span><br><span class="line">t.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="built_in">print</span>(threading.<span class="built_in">enumerate</span>())</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(threading.<span class="built_in">enumerate</span>()) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="comment">#打印</span></span><br><span class="line">[&lt;_MainThread(MainThread, started <span class="number">10416</span>)&gt;, &lt;Timer(timer, started <span class="number">2768</span>)&gt;]</span><br><span class="line">[&lt;_MainThread(MainThread, started <span class="number">10416</span>)&gt;, &lt;Timer(timer, started <span class="number">2768</span>)&gt;]</span><br><span class="line">[&lt;_MainThread(MainThread, started <span class="number">10416</span>)&gt;, &lt;Timer(timer, started <span class="number">2768</span>)&gt;]</span><br><span class="line">[&lt;_MainThread(MainThread, started <span class="number">10416</span>)&gt;, &lt;Timer(timer, started <span class="number">2768</span>)&gt;]</span><br><span class="line"><span class="number">2018</span>-<span class="number">10</span>-<span class="number">12</span> <span class="number">16</span>:<span class="number">24</span>:<span class="number">44</span>,066 timer <span class="number">2768</span>  <span class="keyword">in</span> worker</span><br><span class="line">[&lt;_MainThread(MainThread, started <span class="number">10416</span>)&gt;, &lt;Timer(timer, started <span class="number">2768</span>)&gt;]</span><br><span class="line">[&lt;_MainThread(MainThread, started <span class="number">10416</span>)&gt;, &lt;Timer(timer, started <span class="number">2768</span>)&gt;]</span><br></pre></td></tr></table></figure>

<p>Timer提供了cancel方法，用来取消一个未执行的函数，如果上面例子中worker函数已经开始执行，cancel就没有任何效果了。</p>
<p>总结<br>Timer是线程Thread的子类，就是线程类，具有线程的能力和特征。<br>它的实例是能够延时执行目标函数的线程，在真正执行目标函数之前，都可以cancel它。<br>cancel方法本质使用Event类实现。这并不是说，线程提供了取消的方法。</p>
<h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p>概念：线程同步，线程间协同，通过某种技术，让一个线程访问某些数据时，其他线程不能访问这些数据，直到该线程完成对数据的操作。</p>
<p>不同操作系统实现技术有所不同，有临界区（Critical Section）、互斥量（Mutex）、信号量（Semaphore）、事件Event等</p>
<h4 id="Event事件"><a href="#Event事件" class="headerlink" title="Event事件"></a>Event事件</h4><hr>
<p>Event事件，是线程间通信机制中最简单的实现，使用一个内部的标记flag，通过flag的True或False的变化来进行操作。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>set()</td>
<td>标记设置为True</td>
</tr>
<tr>
<td>clear()</td>
<td>标记设置为False</td>
</tr>
<tr>
<td>is_set()</td>
<td>标记是否为True</td>
</tr>
<tr>
<td>wait(timeout=None)</td>
<td>设置等待标记为True的时长，None为无限等待。等到返回True，未等到超时了返回False</td>
</tr>
</tbody></table>
<p>需求：</p>
<p>老板雇佣了一个工人，让他生产杯子，老板一直等着这个工人，直到生产了10个杯子。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Event, Thread</span><br><span class="line"></span><br><span class="line">FORMAT = <span class="string">&quot;%(asctime)s %(threadName)s %(thread)s %(message)s&quot;</span></span><br><span class="line">logging.basicConfig(<span class="built_in">format</span>=FORMAT, level=logging.INFO)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">boss</span>(<span class="params">event: Event</span>):</span></span><br><span class="line">    logging.info(<span class="string">&quot;I&#x27;m boss, waitting for U.&quot;</span>)</span><br><span class="line">    event.wait()  <span class="comment">#等待</span></span><br><span class="line">    logging.info(<span class="string">&quot;Good Job.&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span>(<span class="params">event: Event, count=<span class="number">10</span></span>):</span></span><br><span class="line">    logging.info(<span class="string">&quot;i&#x27;m working for U.&quot;</span>)</span><br><span class="line">    cups = []</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        logging.info(<span class="string">&quot;make 1&quot;</span>)</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line">        cups.append(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(cups) &gt;= count:</span><br><span class="line">            event.<span class="built_in">set</span>()   <span class="comment">#通知</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    logging.info(<span class="string">&quot;I&#x27;m finish my job, cups = &#123;&#125;&quot;</span>.<span class="built_in">format</span>(cups))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">event = Event()</span><br><span class="line">t1 = Thread(target=boss, name=<span class="string">&quot;bose&quot;</span>, args=(event,)).start()</span><br><span class="line">t2 = Thread(target=worker, name=<span class="string">&quot;worker&quot;</span>, args=(event,)).start()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>总结<br>使用同一个Event对象的标记flag。<br>谁wait就是等到flag变为True，或等到超时返回False。不限制等待的个数。</p>
<p>wait的使用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Event, Thread</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logging.basicConfig(level=logging.INFO)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do</span>(<span class="params">event:Event, interval:<span class="built_in">int</span></span>):</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> event.wait(interval): <span class="comment"># 条件中使用，返回True或者False</span></span><br><span class="line">        logging.info(<span class="string">&#x27;do sth.&#x27;</span>)</span><br><span class="line"></span><br><span class="line">e = Event()</span><br><span class="line">Thread(target=do, args=(e, <span class="number">3</span>)).start()</span><br><span class="line"></span><br><span class="line">e.wait(<span class="number">10</span>) <span class="comment"># 也可以使用time.sleep(10)</span></span><br><span class="line">e.<span class="built_in">set</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;main exit&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line"></span><br><span class="line">INFO:root:do sth.</span><br><span class="line">INFO:root:do sth.</span><br><span class="line">INFO:root:do sth.</span><br><span class="line">main exit</span><br><span class="line"></span><br><span class="line">Process finished <span class="keyword">with</span> exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>Event的wait优于time.sleep，它会更快的切换到其它线程，提高并发效率。</p>
<hr>
<h4 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h4><p>锁，凡是存在共享资源争抢的地方都可以使用锁，从而保证只有一个使用者可以使用这个资源。</p>
<p>锁，一旦线程获得锁，其它试图获取锁的线程将被阻塞</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>acquire(blocking=True,timeout=-1)</td>
<td>默认阻塞，阻塞可以设置超时时间。非阻塞时，timeout禁止设置。成功获取锁，返回True，否则返回False</td>
</tr>
<tr>
<td>release()</td>
<td>释放锁。可以从任何线程调用释放。已上锁的锁，会被重置为unlocked,未上锁的锁上调用，抛RuntimeError异常。</td>
</tr>
</tbody></table>
<h4 id="加锁和解锁"><a href="#加锁和解锁" class="headerlink" title="加锁和解锁"></a>加锁和解锁</h4><hr>
<p>一般来说，加锁就需要解锁，但是加锁后解锁前，还要有一些代码执行，就有可能抛异常，一旦出现异常，锁是无法释放，但是当前线程可能因为这个异常被终止了，这就产生了死锁。</p>
<p>加锁、解锁常用语句：<br>1、使用try…finally语句保证锁的释放</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:            </span><br><span class="line">    self.lock.acquire()            </span><br><span class="line"><span class="keyword">finally</span>:            </span><br><span class="line">    self.lock.release()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2、with上下文管理，锁对象支持上下文管理</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">self.__lock = threading.Lock() </span><br><span class="line"><span class="keyword">with</span> self.__lock:</span><br><span class="line">     ******</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h4 id="锁的应用场景"><a href="#锁的应用场景" class="headerlink" title="锁的应用场景"></a>锁的应用场景</h4><hr>
<p>锁适用于访问和修改同一个共享资源的时候，即读写同一个资源的时候。</p>
<p>如果全部都是读取同一个共享资源需要锁吗？<br>不需要。因为这时可以认为共享资源是不可变的，每一次读取它都是一样的值，所以不用加锁</p>
<p>使用锁的注意事项：</p>
<ul>
<li>少用锁，必要时用锁。使用了锁，多线程访问被锁的资源时，就成了串行，要么排队执行，要么争抢执行<ul>
<li>举例，高速公路上车并行跑，可是到了省界只开放了一个收费口，过了这个口，车辆依然可以在多车道上一起跑。过收费口的时候，如果排队一辆辆过，加不加锁一样效率相当，但是一旦出现争抢，就必须加锁,一辆辆过。</li>
</ul>
</li>
<li>加锁时间越短越好，不需要就立即释放锁</li>
<li>一定要避免死锁</li>
</ul>
<h4 id="可重入锁RLOCK"><a href="#可重入锁RLOCK" class="headerlink" title="可重入锁RLOCK"></a>可重入锁RLOCK</h4><hr>
<p>可重入锁，是<strong>线程相关</strong>的锁。<br>线程A获得可重复锁，并可以在同一线程中多次成功获取，<strong>不会阻塞</strong>。最后要在线程A中做和acquire次数相同的release。release多了会报错。有个count在计数。属主owner会记录当前是谁在使用锁。</p>
<p>当锁未释放完，其他线程获得锁就会阻塞，直到当前持有锁的线程释放完锁。</p>
<h4 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h4><hr>
<p>构造方法Condition(lock=None)，可以传入一个Lock或Rlock对象，默认是Rlock。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>acquire(*args)</td>
<td>获取锁</td>
</tr>
<tr>
<td>wait(self,timeout = None)</td>
<td>等待或超时</td>
</tr>
<tr>
<td>notify（n =1）</td>
<td>唤醒至多指定指定个数的等待的线程，没有等待的线程就没有任何操作</td>
</tr>
<tr>
<td>notify_all()</td>
<td>唤醒所有等待的线程</td>
</tr>
</tbody></table>
<p>Condition用于生产者、消费者模型，为了解决生产者消费者速度匹配的问题。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/python/" rel="tag"># python</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2017/11/01/16%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" rel="prev" title="网络编程">
                  <i class="fa fa-chevron-left"></i> 网络编程
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2017/12/16/18%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E6%AD%A5%E9%AA%A4/" rel="next" title="python-日志分析步骤">
                  python-日志分析步骤 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">luoqian</span>
</div>
  <div class="powered-by">تطبيق الموقع <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
